MOV AX, 0xFFFF
MOV BX, 0xFFFF

CALL outputBinToDec

HALT


// Outputs AX contents in Decimal to console
outputBinToDec:

MOV [nextNumberToConvertBinToDec], AX

// Initialise pointer for array
CALL globalPointerInitialise
CALL globalPointerSetDirectionIncrement

// start of loop, this loop is to fill memory with the digits of the number starting from the last digit.
binToDecFillArrayLoop: 

MOV AX, [nextNumberToConvertBinToDec]
CALL modulusbyten
ADD AX, '0'
CALL globalAXIntoPointer

MOV AX, [nextNumberToConvertBinToDec]
CALL divisionbyten
MOV [nextNumberToConvertBinToDec], AX

CALL globalPointerUpdate

MOV AX, [nextNumberToConvertBinToDec]
CMP AX, 0d10
JGE binToDecFillArrayLoop

// end of loop

ADD AX, '0'
CALL printchar
CALL globalPointerSetDirectionDecrement

// Updating pointer bc last loop increments 1 too many times..
CALL globalPointerUpdate

// start of loop, this loop prints the digits generated by the previous one but in reverse order
binToHexOutputLoop:

CALL globalGetDataAtPointerIntoAX
CALL printchar

CALL globalPointerUpdate

// End condition, could be in function maybe
MOV AX, [GlobalPointer]
MOV BX, GlobalPointerStart
MOV BX, [BX]
CMP AX, BX

JL return

JMP binToHexOutputLoop

// END OF outputBinToDec


// Jump to this to use as: if () {return}.
return:
RET
// END OF return


// Do not use this inside a function already using this at some preceeding function call
// Global pointer functions


globalPointerInitialise:
MOV AX, GlobalPointerStart
MOV AX, [AX]
MOV [GlobalPointer], AX
RET

globalGetDataAtPointerIntoAX:
MOV BX, [GlobalPointer]
MOV AX, [BX]
RET

globalPointerSetDirectionIncrement:
MOV BX, 0x0
MOV [GlobalPointerDirection], BX
RET

globalPointerSetDirectionDecrement:
MOV BX, 0x1
MOV [GlobalPointerDirection], BX
RET

globalAXIntoPointer:
MOV BX, [GlobalPointer]
MOV [BX], AX
RET


globalPointerUpdate:

// Check flag decrementing
MOV BX, [GlobalPointerDirection]
CMP BX, 0x0
JEQ GlobalPointerIncrement

MOV AX, [GlobalPointer]
DEC AX
MOV [GlobalPointer], AX

RET

GlobalPointerIncrement:

MOV AX, [GlobalPointer]
INC AX
MOV [GlobalPointer], AX

RET



modulusbyten:
CALL splitvalue
MOD AX, 0d10
MOD BX, 0d10
QSL AX
QSL AX
ADD AX, BX
MOD AX, 0d10
RET

divisionbyten:
CALL splitvalue
MOV [divisionbytentemplow], BX
MOV BX, AX

DIV AX, 0d10
MOV [divisionbytentemphighfinal], AX

MOD BX, 0d10
QSL BX
QSL BX

MOV AX, [divisionbytentemplow]

ADD BX, AX
DIV BX, 0d10

MOV AX, [divisionbytentemphighfinal]
QSL AX
QSL AX

ADD AX, BX

RET


32bitdivisionbyten:

MOV [32divlow], BX

CALL 16bitdivisionbyten
MOV [32divhigh], AX

MOV AX, [32divlow]
QSL BX
QSL BX
MOV [32divrem], BX

CALL splitvalue
MOV [16divlow], BX

MOV BX, [32divrem]
ADD AX, BX

MOV BX, AX
DIV AX, 0d10
MOD BX, 0d10

MOV [TEMP2], AX

MOV AX, [16divlow]
QSL BX
QSL BX
ADD AX, BX

MOV BX, AX
DIV AX, 0d10
MOD BX, 0d10

MOV [32divrem], BX
MOV BX, [TEMP2]
QSL BX
QSL BX
ADD BX, AX

MOV AX, [32divhigh]

RET



16bitdivisionbyten:

CALL splitvalue
MOV [16divhigh], AX
MOV [16divlow], BX

MOV BX, AX
DIV AX, 0d10
MOD BX, 0d10
MOV [16divhigh], AX
// ResultHigh in AX Remainder in BX

MOV AX, [16divlow]
QSL BX
QSL BX
ADD AX, BX

MOV BX, AX
DIV AX, 0d10
MOD BX, 0d10

MOV [16divrem], BX

MOV BX, [16divhigh]
QSL BX
QSL BX
ADD AX, BX
MOV BX, [16divrem]
// Remainder in BX ResultLow in AX

RET


splitvalue:

MOV BX, AX

//BX
MOV [AXCOPY], AX
MOV AX, 0x00FF
AND BX, AX
MOV AX, [AXCOPY]

//AX
SUB AX, BX
QSR AX
QSR AX

// WASP SHR BUG FIX START
MOV [BXCOPY], BX
MOV BX, 0x00FF
AND AX, BX
MOV BX, [BXCOPY]
// WASP SHR BUG FIX END

RET


// FUNCTION START
hexadd:

CALL anbngenerator

// This works becuase of the state anbngenerator leaves.
MOV AX, [AN01]
MOV BX, [BN01]
ADD AX, BX

CALL splitvalue

// right result final in temp 1
MOV [TEMP1], BX

MOV BX, [AN00]
ADD AX, BX
MOV BX, [BN00]
ADD AX, BX

MOV BX, [TEMP1]

RET
// hexadd END

// FUNCTION START
// Splits ax and bx into 4 values a0,a1,b0,b1 containing low and high.
anbngenerator:

MOV [TEMP1], BX

CALL splitvalue

MOV [AN00], AX
MOV [AN01], BX

MOV AX, [TEMP1]

CALL splitvalue

MOV [BN00], AX
MOV [BN01], BX

RET
// anbngenerator END


printchar:
MOV [0x00F0], AX
MOV BX, 0x0001
MOV [0xF2], BX
printcharloop:
MOV BX, [0x00F2]
CMP BX, 0x1
JEQ printcharloop
RET
// Prints char in AX


32divhigh: DC.W 0x1FFF
32divlow: DC.W 0x1FFE
32divrem: DC.W 0x1FF7
AXCOPY: DC.W 0x1FFD
BXCOPY: DC.W 0x1FFC
16divlow: DC.W 0x1FFB
16divhigh: DC.W 0x1FFA
16divrem: DC.W 0x1FF8
copy: DC.W 0x1FF9

AN00: DC.W 0x1FE6
AN01: DC.W 0x1FE5
BN00: DC.W 0x1FE4
BN01: DC.W 0x1FE3
TEMP1: DC.W 0x1FEB
TEMP2: DC.W 0x1FEA
TEMP3: DC.w 0x1FE9


takenumericalinputvalue: DC.W 0x1FE0
nextNumberToConvertBinToDec: DC.W 0x1FDF

// Vars for 'array' or 'GlobalPointer'
GlobalPointerStart: DC.W 0x1000
GlobalPointer: DC.W 0x1FDE
GlobalPointerDirection: DC.W 0x1FDD
// 0 == increment, 1 == decrement

AXCopyForWrapper: DC.W 0x1FDC

divisionbytentemplow: DC.W 0x1FD0
divisionbytentemphighfinal: DC.W 0x1FCF