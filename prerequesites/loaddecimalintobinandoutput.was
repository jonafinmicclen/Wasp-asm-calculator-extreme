CALL outputTextFromMemory
CALL takeInput
MOV AX, [operandA]
MOV BX, [operandB]
HALT



// Outputs AX contents in Decimal to console
outputBinToDec:

MOV [nextNumberToConvertBinToDec], AX

// Initialise pointer for array
CALL globalPointerInitialise
CALL globalPointerSetDirectionIncrement

// start of loop, this loop is to fill memory with the digits of the number starting from the last digit.
binToDecFillArrayLoop: 

MOV AX, [nextNumberToConvertBinToDec]
CALL modulusbyten
ADD AX, '0'
CALL globalAXIntoPointer

MOV AX, [nextNumberToConvertBinToDec]
CALL divisionbyten
MOV [nextNumberToConvertBinToDec], AX

CALL globalPointerUpdate

MOV AX, [nextNumberToConvertBinToDec]
CMP AX, 0d10
JGE binToDecFillArrayLoop

// end of loop

ADD AX, '0'
CALL printchar
CALL globalPointerSetDirectionDecrement

// Updating pointer bc last loop increments 1 too many times..
CALL globalPointerUpdate

// start of loop, this loop prints the digits generated by the previous one but in reverse order
binToHexOutputLoop:

CALL globalGetDataAtPointerIntoAX
CALL printchar

CALL globalPointerUpdate

// End condition, could be in function maybe
MOV AX, [GlobalPointer]
MOV BX, GlobalPointerStart
MOV BX, [BX]
CMP AX, BX

JL return

JMP binToHexOutputLoop

// END OF outputBinToDec



takenumericalinput:
MOV AX, 0x0
MOV [takenumericalinputvalue], AX
takenumericalinputloop:
CALL readnext

// Put delimiters here
MOV [operator], AX  // This stores everything but its only left unchanged when a valid delimiter is present so it works but is a bit cheap
CMP AX, '+' 
JEQ return
CMP AX, '-' 
JEQ return
CMP AX, '*' 
JEQ return
CMP AX, '/' 
JEQ return
CMP AX, '=' 
JEQ return

SUB AX, '0'
MOV BX, [takenumericalinputvalue]
MUL BX, 0xA
ADD BX, AX
MOV [takenumericalinputvalue], BX
JMP takenumericalinputloop
// END OF takenumericalinput



// Taken from console test
readnext:
readnextloop:
MOV AX, [0x00F5]
CMP AX, 0x0
JEQ readnextloop
MOV AX, [0x00F3]
MOV BX, 0x00F5
MOV [BX], 0x0
RET
// END OF readnext



// Jump to this to use as: if () {return}.
return:
RET
// END OF return



printchar:
MOV [0x00F0], AX
MOV AX, 0x0001
MOV [0xF2], AX
printcharloop:
MOV AX, [0x00F2]
CMP AX, 0x1
JEQ printcharloop
RET
// Prints char in AX



// Do not use this inside a function already using this at some preceeding function call
// Global pointer functions


globalPointerInitialise:
MOV AX, GlobalPointerStart
MOV AX, [AX]
MOV [GlobalPointer], AX
RET

globalGetDataAtPointerIntoAX:
MOV BX, [GlobalPointer]
MOV AX, [BX]
RET

globalPointerSetDirectionIncrement:
MOV BX, 0x0
MOV [GlobalPointerDirection], BX
RET

globalPointerSetDirectionDecrement:
MOV BX, 0x1
MOV [GlobalPointerDirection], BX
RET

globalAXIntoPointer:
MOV BX, [GlobalPointer]
MOV [BX], AX
RET


globalPointerUpdate:

// Check flag decrementing
MOV BX, [GlobalPointerDirection]
CMP BX, 0x0
JEQ GlobalPointerIncrement

MOV AX, [GlobalPointer]
DEC AX
MOV [GlobalPointer], AX

RET

GlobalPointerIncrement:

MOV AX, [GlobalPointer]
INC AX
MOV [GlobalPointer], AX

RET

// Runs function in BX
MaintainAXRegisterFunctionWrapper:
MOV [AXCopyForWrapper], AX
CALL AX
MOV AX, [AXCopyForWrapper]
RET



// FUNCTION START
splitvalue:

MOV BX, AX

//BX
MOV [AXCOPY], AX
MOV AX, 0x00FF
AND BX, AX
MOV AX, [AXCOPY]

//AX
SUB AX, BX
QSR AX
QSR AX

// WASP SHR BUG FIX START
MOV [BXCOPY], BX
MOV BX, 0x00FF
AND AX, BX
MOV BX, [BXCOPY]
// WASP SHR BUG FIX END

RET
// Result, AX contains 0x**00 >> 8, BX contains 0x00** 
// splitvalue END


modulusbyten:
CALL splitvalue
MOD AX, 0d10
MOD BX, 0d10
QSL AX
QSL AX
ADD AX, BX
MOD AX, 0d10
RET

divisionbyten:
CALL splitvalue
MOV [divisionbytentemplow], BX
MOV BX, AX

DIV AX, 0d10
MOV [divisionbytentemphighfinal], AX

MOD BX, 0d10
QSL BX
QSL BX

MOV AX, [divisionbytentemplow]

ADD BX, AX
DIV BX, 0d10

MOV AX, [divisionbytentemphighfinal]
QSL AX
QSL AX

ADD AX, BX

RET

NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP



32bitdivisionbyten:

MOV [32divlow], BX

CALL 16bitdivisionbyten
MOV [32divhigh], AX

MOV AX, [32divlow]
QSL BX
QSL BX
MOV [32divrem], BX

CALL splitvalue
MOV [16divlow], BX

MOV BX, [32divrem]
ADD AX, BX

MOV BX, AX
DIV AX, 0d10
MOD BX, 0d10

MOV [TEMP2], AX

MOV AX, [16divlow]
QSL BX
QSL BX
ADD AX, BX

MOV BX, AX
DIV AX, 0d10
MOD BX, 0d10

MOV [32divrem], BX
MOV BX, [TEMP2]
QSL BX
QSL BX
ADD BX, AX

MOV AX, [32divhigh]
MOV [32divlow], BX

RET



16bitdivisionbyten:

CALL splitvalue
MOV [16divhigh], AX
MOV [16divlow], BX

MOV BX, AX
DIV AX, 0d10
MOD BX, 0d10
MOV [16divhigh], AX
// ResultHigh in AX Remainder in BX

MOV AX, [16divlow]
QSL BX
QSL BX
ADD AX, BX

MOV BX, AX
DIV AX, 0d10
MOD BX, 0d10

MOV [16divrem], BX

MOV BX, [16divhigh]
QSL BX
QSL BX
ADD AX, BX
MOV BX, [16divrem]
// Remainder in BX ResultLow in AX

RET



// Outputs AX contents in Decimal to console
outputBinToDec32:

MOV [nextNumberToConvertBinToDecHigh], AX
MOV [nextNumberToConvertBinToDecLow], BX

// Initialise pointer for array
CALL globalPointerInitialise
CALL globalPointerSetDirectionIncrement

// start of loop, this loop is to fill memory with the digits of the number starting from the last digit.
binToDecFillArrayLoop32: 

MOV AX, [nextNumberToConvertBinToDecHigh]
MOV BX, [nextNumberToConvertBinToDecLow]

CALL 32bitdivisionbyten
MOV [nextNumberToConvertBinToDecHigh], AX
MOV [nextNumberToConvertBinToDecLow], BX

MOV AX, [32divrem] 
ADD AX, '0'
CALL globalAXIntoPointer

CALL globalPointerUpdate

MOV AX, [nextNumberToConvertBinToDecHigh]
CMP AX, 0x0
JNE notzero
MOV BX, [nextNumberToConvertBinToDecLow]
CMP BX, 0d9
JL exitLoop
notzero:
JMP binToDecFillArrayLoop32
exitLoop:

// end of loop
MOV BX, [nextNumberToConvertBinToDecLow]
MOD BX, 0d10
ADD BX, '0'
MOV AX, BX
CALL printchar
CALL globalPointerSetDirectionDecrement

// Updating pointer bc last loop increments 1 too many times..
CALL globalPointerUpdate

// start of loop, this loop prints the digits generated by the previous one but in reverse order
binToHexOutputLoop32:

CALL globalGetDataAtPointerIntoAX
CALL printchar

CALL globalPointerUpdate

// End condition, could be in function maybe
MOV AX, [GlobalPointer]
MOV BX, GlobalPointerStart
MOV BX, [BX]
CMP AX, BX

JL return

JMP binToHexOutputLoop32

// END OF outputBinToDec


outputTextFromMemory:
MOV BX, text0
outputTextFromMemoryLoop:
MOV AX, [BX]
CMP AX, 0xFF
JEQ return
CALL printchar
ADD BX, 0x1
JMP outputTextFromMemoryLoop




takeInput:
CALL takenumericalinput
MOV AX, [takenumericalinputvalue]
MOV [operandA], AX
CALL takenumericalinput
MOV AX, [takenumericalinputvalue]
MOV [operandB], AX
RET



calculateResultant:
MOV AX, [operator]
COMP AX, '*'
JNE notmultiply

MOV AX, [operandA]
MOV BX, [operandB]
CALL hexmulitply

notmultiply:



CALL outputBinToDec32




// VARIABLES

takenumericalinputvalue: DC.W 0x1FFF
nextNumberToConvertBinToDec: DC.W 0x1FFE

// Vars for 'array' or 'GlobalPointer'
GlobalPointerStart: DC.W 0x1000
GlobalPointer: DC.W 0x1FFC
GlobalPointerDirection: DC.W 0x1FFB
// 0 == increment, 1 == decrement

AXCopyForWrapper: DC.W 0x1FFA

AXCOPY: DC.W 0x1FF8
BXCOPY: DC.W 0x1FFD

divisionbytentemplow: DC.W 0x1FF7
divisionbytentemphighfinal: DC.W 0x1FF6

32divhigh: DC.W 0x1DFF
32divlow: DC.W 0x1DFE
32divrem: DC.W 0x1DF7
16divlow: DC.W 0x1DFB
16divhigh: DC.W 0x1DFA
16divrem: DC.W 0x1DF8
copy: DC.W 0x1DF9

TEMP2: DC.W 0x1DF8

operandA: DC.W 0x1DF7
operandB: DC.W 0x1DF6
operator: DC.W 0x1DF5
resultant: DC.W 0x1DF4

nextNumberToConvertBinToDecHigh: DC.W 0x1DF7
nextNumberToConvertBinToDecLow: DC.W 0x1DF6

// Output text begin here
text0: DC.W 'P'
text1: DC.W 'l'
text2: DC.W 'e'
text3: DC.W 'a'
text4: DC.W 's'
text5: DC.W 'e'
text6: DC.W ' '
text7: DC.W 'e'
text8: DC.W 'n'
text9: DC.W 't'
text10: DC.W 'e'
text11: DC.W 'r'
text12: DC.W ' '
text13: DC.W 'y'
text14: DC.W 'o'
text15: DC.W 'u'
text16: DC.W 'r'
text17: DC.W ' '
text18: DC.W 'e'
text19: DC.W 'x'
text20: DC.W 'p'
text21: DC.W 'r'
text22: DC.W 'e'
text23: DC.W 's'
text24: DC.W 's'
text25: DC.W 'i'
text26: DC.W 'o'
text27: DC.W 'n'
text28: DC.W ' '
text29: DC.W 'i'
text30: DC.W 'n'
text31: DC.W ' '
text32: DC.W 't'
text33: DC.W 'h'
text34: DC.W 'e'
text35: DC.W ' '
text36: DC.W 'f'
text37: DC.W 'o'
text38: DC.W 'r'
text39: DC.W 'm'
text40: DC.W 'a'
text41: DC.W 't'
text42: DC.W ' '
text43: DC.W '"'
text44: DC.W 'a'
text45: DC.W '+'
text46: DC.W 'b'
text47: DC.W '='
text48: DC.W '"'
text49: DC.W ' '
text50: DC.W 'm'
text51: DC.W 'a'
text52: DC.W 'x'
text53: DC.W ' '
text54: DC.W 'i'
text55: DC.W 'n'
text56: DC.W 'p'
text57: DC.W 'u'
text58: DC.W 't'
text59: DC.W ' '
text60: DC.W 'n'
text61: DC.W 'u'
text62: DC.W 'm'
text63: DC.W 'b'
text64: DC.W 'e'
text65: DC.W 'r'
text66: DC.W ' '
text67: DC.W 'i'
text68: DC.W 's'
text69: DC.W ' '
text70: DC.W '6'
text71: DC.W '5'
text72: DC.W '5'
text73: DC.W '3'
text74: DC.W '5'
text75: DC.W ':'
textendmarker: DC.W 0xFF
