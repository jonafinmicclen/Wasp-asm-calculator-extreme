Main:
// Initialise/reset variables
CALL ResetFragmentedNumberToZero

// Print message
MOV BX, enterExpressionPrompt
CALL PrintTextFromMemory

// Take inputs
CALL InputNumberToFrag

MOV AX, [operator]
CMP AX, '+'
JEQ MainHandleAddition
CMP AX, '-'
JEQ MainHandleSubtraction

MOV BX, unexpectedError
CALL PrintTextFromMemory
HALT



MainHandleAddition:
MOV AX, 0x400
CALL CopyFragmentedNumberToAddressInAXEndFlagged
CALL ResetFragmentedNumberToZero
CALL InputNumberToFrag
MOV AX, 0x400
CALL AddFragAtAXToFrag
CALL PrintFragmentedNumber 
MOV AX, 0xA
CALL PrintChar
JMP Main



MainHandleSubtraction:

CALL GetFragmentedNumberLengthInMemoryIntoBX
PUSH BX

MOV AX, 0x400
CALL CopyFragmentedNumberToAddressInAXEndFlagged

CALL ResetFragmentedNumberToZero

CALL InputNumberToFrag

// If AX more use first handler otherwise use the other one
CALL GetFragmentedNumberLengthInMemoryIntoBX
CMP BX, AX
JL MainHandleSubtractionAXGreaterCase

MOV AX, 0x400
CALL CmpLoadedFragToFragAtAXGreaterThan
CMP AX, 0x0
JEQ MainHandleSubtractionAXGreaterCase
JMP MainHandleSubtractionBXGreaterCase


MainHandleSubtractionAXGreaterCase:

MOV AX, 0x500
CALL CopyFragmentedNumberToAddressInAXEndFlagged

MOV AX, 0x400
CALL LoadFragAtAX

MOV AX, 0x500
CALL SubFragAtAXToFrag

CALL PrintFragmentedNumber

MOV AX, 0xA
CALL PrintChar

JMP Main


MainHandleSubtractionBXGreaterCase:

MOV AX, 0x400
CALL SubFragAtAXToFrag

// Print negative sign
MOV AX, 0x2D
CALL PrintChar

CALL PrintFragmentedNumber

MOV AX, 0xA
CALL PrintChar

JMP Main



MainHandleMultiplication:



// If any bugs happen make sure a function using the pointer doesn't call another also using the pointer

// Must ensure this function correctly updates the length of fragmented nubmer, I think it does now that i fixed it ..
AddAXToFragmentedNumberOffsettPointerBX:

PUSH AX
PUSH BX
CALL ResetSignificandPointerToStart
MOV AX, [fragmentedSignificandPointer]
POP BX 
ADD AX, BX
MOV [fragmentedSignificandPointer], AX
POP AX

AddAXToFragmentedNumberLoop:

CALL SplitAX

PUSH AX

MOV AX, [fragmentedSignificandPointer]
MOV AX, [AX]
ADD AX, BX

CALL SplitAX

PUSH AX

MOV AX, [fragmentedSignificandPointer]
MOV [AX], BX

POP AX
POP BX

ADD AX, BX
CALL IncrementPointerBX

CMP AX, 0x0
JNE AddAXToFragmentedNumberLoop

// Check if pointer is more than end first
MOV AX, [fragmentedSignificandPointer]
DEC AX
MOV BX, [significandEndVariable]
CMP AX, BX
JL DontUpdateEndVar
MOV [significandEndVariable], AX
DontUpdateEndVar:

RET



// This entire function is trash
MulFragmentedNumberByTen:

// Initialise iterations counter
MOV AX, 0x0
MOV [MulFragmentedNumberByTenIterations], AX

// Copy the number to multiply segments by ten
CALL CopyFragmentedNumber
// Reset number to 0 to add products into
CALL ResetFragmentedNumberToZero


// Find start and end address of fragmented number
MOV AX, [immutableFragCopyStartPointer]
MOV BX, [immutableFragCopyLength]
ADD BX, AX
// AX Contains pointer to start BX contains pointer to end

MulFragmentedNumberByTenLoop:

// Save pointer and end address
PUSH AX
PUSH BX

MOV AX, [AX]
MUL AX, 0xA
MOV BX, [MulFragmentedNumberByTenIterations]
CALL AddAXToFragmentedNumberOffsettPointerBX

// Increase counter
MOV AX, [MulFragmentedNumberByTenIterations]
INC AX
MOV [MulFragmentedNumberByTenIterations], AX

// Get Pointer and end address
POP BX
POP AX
// Increment Pointer and continue if not out of bounds
INC AX
CMP BX, AX
JGE MulFragmentedNumberByTenLoop

RET



DivFragmentedNumberByTenRemInAX:

CALL ResetSignificandPointerToEnd
MOV BX, 0x0
PUSH BX

DivFragmentedNumberByTenRemInAXLoop:

MOV AX, [fragmentedSignificandPointer]
MOV AX, [AX]

POP BX
MUL BX, 0x10
MUL BX, 0x10
ADD AX, BX
MOV BX, AX

DIV AX, 0xA
MOD BX, 0xA
PUSH BX

MOV BX, [fragmentedSignificandPointer]
MOV [BX], AX

CALL DecrementPointerBX

MOV AX, [fragmentedSignificandPointer]
MOV BX, [significandStartConstant]
CMP AX, BX
JGE DivFragmentedNumberByTenRemInAXLoop

POP AX
RET



// Untested takes pointer to start of a fragmented number and adds it to the currently loaded fragmented number
AddFragToOtherFragPtrInAXLengthInBX:

// Reset iteration counter to 0 while maintaining AX
PUSH AX
MOV AX, 0x0
MOV [TempAddFragToOtherFragPtrInBXLengthInAXIteration], AX
POP AX

// Convert length to end address of number, Decrement BX as 0 counts as one
ADD BX, AX

AddFragToOtherFragPtrInAXLengthInBXLoop:

// Store pointer and end address for loop end condition
PUSH AX
PUSH BX

// Add current fragment to loaded fragment
MOV AX, [AX]
MOV BX, [TempAddFragToOtherFragPtrInBXLengthInAXIteration]
CALL AddAXToFragmentedNumberOffsettPointerBX

// Increment interation counter
MOV BX, [TempAddFragToOtherFragPtrInBXLengthInAXIteration]
INC BX
MOV [TempAddFragToOtherFragPtrInBXLengthInAXIteration], BX

// Retrieve pointer and end address
POP BX
POP AX
// Increment pointer
INC AX
// Check if pointer is at end of number
CMP AX, BX

JL AddFragToOtherFragPtrInAXLengthInBXLoop

RET








NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP

// Use variable to access location of copied number, COPPIED NUMBER IS IMMUTABLE
CopyFragmentedNumber:

CALL ResetSignificandPointerToStart
CALL GetFragmentedNumberLengthInMemoryIntoBX
MOV [immutableFragCopyLength], BX
MOV BX, [fragmentedSignificandPointer]
SUB BX, AX
DEC BX
MOV AX, BX
MOV [immutableFragCopyStartPointer], AX
// AX Contains start of the IMMUTABLE copy

CopyFragmentedNumberLoop:

MOV BX, [fragmentedSignificandPointer]
MOV BX, [BX]
MOV [AX], BX
INC AX

CALL IncrementPointerBX

MOV BX, [significandStartConstant]
CMP AX, BX 
JL CopyFragmentedNumberLoop

PUSH AX
Call GetFragmentedNumberLengthInMemoryIntoBX
POP BX
SUB BX, AX
DEC BX

RET


// Use variable to access location of copied number, COPPIED NUMBER IS IMMUTABLE
CopyFragmentedNumberToAddressInAXEndFlagged:

PUSH AX
CALL ResetSignificandPointerToStart
CALL GetFragmentedNumberLengthInMemoryIntoBX
POP AX
ADD BX, AX

CopyFragmentedNumberToAddressInAXEndFlaggedLoop:
PUSH BX
PUSH AX

MOV BX, [fragmentedSignificandPointer]
MOV BX, [BX]
MOV [AX], BX

CALL IncrementPointerBX
CALL GetFragmentedNumberLengthInMemoryIntoBX
POP AX
POP BX
INC AX

CMP BX, AX
JGE CopyFragmentedNumberToAddressInAXEndFlaggedLoop

// End flag is abcd
MOV [AX], 0xABCD

RET

GetFragmentedNumberLengthInMemoryIntoBX:

MOV AX, [significandStartConstant]
MOV BX, [significandEndVariable]
SUB BX, AX
MOV AX, BX

RET



ResetSignificandPointerToStart:
MOV BX, [significandStartConstant]
MOV [fragmentedSignificandPointer], BX
RET



ResetSignificandPointerToEnd:
MOV BX, [significandEndVariable]
MOV [fragmentedSignificandPointer], BX
RET



IncrementPointerBX:
MOV BX, [fragmentedSignificandPointer]
INC BX
MOV [fragmentedSignificandPointer], BX
RET



DecrementPointerBX:
MOV BX, [fragmentedSignificandPointer]
DEC BX
MOV [fragmentedSignificandPointer], BX
RET




SplitAX:

MOV BX, AX

//BX
PUSH AX
MOV AX, 0x00FF
AND BX, AX
POP AX

//AX
SUB AX, BX
QSR AX
QSR AX

// WASP SHR BUG FIX START
PUSH BX
MOV BX, 0x00FF
AND AX, BX
POP BX
// WASP SHR BUG FIX END
// Result, AX contains 0x**00 >> 8, BX contains 0x00** 
RET



// Reads next char, ignores enter
ReadNext:

// Wait for ready flag
MOV AX, [0x00F5]
CMP AX, 0x0
JEQ ReadNext

// Read char
MOV AX, [0x00F3]

// Switch ready flag
MOV BX, 0x00F5
MOV [BX], 0x0

MOV BX, AX

PUSH AX
PUSH BX
CALL PrintChar
POP BX
POP AX

// Ensure character is not enter
CMP BX, 0xA
JEQ ReadNext

// Check if last two characters are xx
CMP BX, 'x'
JNE NotX
// IF X

// Halt IF LastCharX
MOV BX, [lastCharX]
JMP ReadNext
CMP BX, 0x1
JNE NotLastCharX
HALT
NotLastCharX:

// Update LastCharX flag
MOV BX, 0x1
MOV [lastCharX], BX

RET

// ELSE reset lastCharX flag then return
NotX:
MOV BX, 0x0
MOV [lastCharX], BX

RET



InputNumberToFrag:

CALL ReadNext
// Push for end condition functions modifiying ax
PUSH AX

// End condition
CALL IsAXNumeric
CMP AX, 0x0
JEQ IfNotNumeric

// Add digit to frag
POP AX
SUB AX, '0'
CALL PushDigitInAXIntoFrag

JMP InputNumberToFrag

IfNotNumeric:
POP AX

// Store potential operator for later
MOV [operator], AX

// Check its an operator
CMP AX, '+'
JEQ Return
CMP AX, '-'
JEQ Return
CMP AX, '='
JEQ Return

// Unrecognised operator
MOV BX, unrecognisedOperator
CALL PrintTextFromMemory
// Restart due to error
JMP Main



// Input in AX bool return in AX
IsAXNumeric:

CMP AX, '0'
JGE MoreThanOrEqualToZero
MOV AX, 0x0
RET
MoreThanOrEqualToZero:

MOV BX, '9'
CMP BX, AX
JGE LessThanOrEqualToNine
MOV AX, 0x0
RET
LessThanOrEqualToNine:

MOV AX, 0x1

RET


PushDigitInAXIntoFrag:
PUSH AX
CALL MulFragmentedNumberByTen
POP AX
MOV BX, 0x0
CALL AddAXToFragmentedNumberOffsettPointerBX
RET


Return:
RET

ResetFragmentedNumberToZero:

// Reset Sign
MOV AX, 0x0
MOV [signOfFragmented], AX

// Reset signifcand
MOV AX, [significandStartConstant]
MOV BX, [significandEndVariable]

ResetFragmentedNumberToZeroLoop:

MOV [AX], 0x0
INC AX
CMP BX, AX
JGE ResetFragmentedNumberToZeroLoop

MOV BX, [significandStartConstant]
MOV AX, significandEndVariable
MOV [AX], BX

RET



PrintChar:
MOV [0xF0], AX
MOV AX, 0x0001
MOV [0xF2], AX
PrintCharLoop:
MOV AX, [0x00F2]
CMP AX, 0x1
JEQ PrintCharLoop
RET


// Kinda gross use of stack but its perfect
PrintFragmentedNumber:

// This is end flag for printing number
MOV AX, 0xABCD
PUSH AX

PrintFragmentedNumberLoopFirst:

// Div frag by ten and push Remainder
CALL DivFragmentedNumberByTenRemInAX
ADD AX, '0'
PUSH AX

// Increment and end condition
CALL IsFragmentedNumberZero
CMP AX, 0x1
JNE PrintFragmentedNumberLoopFirst

MOV BX, 0xABCD

PrintFragmentedNumberLoopSecond:

POP AX

CMP AX, BX
JEQ Return

PUSH AX
CALL PrintChar
POP AX

JMP PrintFragmentedNumberLoopSecond



IsFragmentedNumberZero:

CALL ResetSignificandPointerToStart

IsFragmentedNumberZeroLoop:

MOV BX, [fragmentedSignificandPointer]
MOV AX, [BX]
CMP AX, 0x0
JNE NotZero

CALL IncrementPointerBX
MOV AX, [fragmentedSignificandPointer]
MOV BX, [significandEndVariable]
CMP BX, AX
JGE IsFragmentedNumberZeroLoop

MOV AX, 0x1
RET

NotZero:
MOV AX, 0x0
RET



SubFragAtAXToFrag:

// Ax contains start of frag to add from, end of this frag is indicated by abcd
// BX will be iteration counter
MOV BX, 0x0

SubFragAtAXToFragLoop:

PUSH AX
PUSH BX

MOV AX, [AX]
MOV BX, 0xABCD
CMP AX, BX
JEQ SubFragAtAXToFragLoopEnd

POP BX
PUSH BX

CALL SubAXToFragmentedNumberOffsettPointerBX

POP BX
POP AX

INC AX
INC BX

JMP SubFragAtAXToFragLoop

SubFragAtAXToFragLoopEnd:

//Cleanup stack
POP AX
POP BX

RET

AddFragAtAXToFrag:

// Ax contains start of frag to add from, end of this frag is indicated by abcd
// BX will be iteration counter
MOV BX, 0x0

AddFragAtAXToFragLoop:

PUSH AX
PUSH BX

MOV AX, [AX]
MOV BX, 0xABCD
CMP AX, BX
JEQ AddFragAtAXToFragLoopEnd

POP BX
PUSH BX

CALL AddAXToFragmentedNumberOffsettPointerBX

POP BX
POP AX

INC AX
INC BX

JMP AddFragAtAXToFragLoop

AddFragAtAXToFragLoopEnd:

//Cleanup stack
POP AX
POP BX

RET


// Put pointer to start of text in BX, End flag is 0xFF
PrintTextFromMemory:
MOV AX, [BX]
CMP AX, 0xFF
JEQ Return
PUSH BX
CALL PrintChar
POP BX
INC BX
JMP PrintTextFromMemory



// Only can input half a word, assumes that BX < AX

SubAXToFragmentedNumberOffsettPointerBX:

PUSH AX
PUSH BX
CALL ResetSignificandPointerToStart
MOV AX, [fragmentedSignificandPointer]
POP BX 
ADD AX, BX
MOV [fragmentedSignificandPointer], AX
POP BX

SubAXToFragmentedNumberOffsettPointerBXLoop:

// Get num at pointer
MOV AX, [fragmentedSignificandPointer]
MOV AX, [AX]

// IF result will be positive
CMP AX, BX
JL SubAXToFragmentedNumberOffsettPointerBNotGreaterOrEqualAXBX

// Result of subtraction is positive so do it replace and return
SUB AX, BX
MOV BX, [fragmentedSignificandPointer]
MOV [BX], AX
RET

// IF result would be negative
SubAXToFragmentedNumberOffsettPointerBNotGreaterOrEqualAXBX:

// Result will be negative so take from next digit, by setting BX to 1 and adding 100 to subtraction result
ADD AX, 0x80
ADD AX, 0x80
SUB AX, BX
MOV BX, [fragmentedSignificandPointer]
MOV [BX], AX

CALL IncrementPointerBX
MOV BX, 0x1

JMP SubAXToFragmentedNumberOffsettPointerBXLoop



MulFragmentByOtherFragmentStartingAtAX:

RET



// Stopping at stop flag 0xABCD will inpute the saved frag into the currently loaded one
LoadFragAtAX:

PUSH AX
CALL ResetSignificandPointerToStart
POP AX

LoadFragAtAXLoop:

PUSH AX
MOV AX, [AX]

MOV BX, 0xABCD
CMP AX, BX
JEQ LoadFragAtAXLoopExit

// Get num from copied frag and move it into the loaded frag
MOV BX, [fragmentedSignificandPointer]
MOV [BX], AX
POP AX

INC AX
CALL IncrementPointerBX

JMP LoadFragAtAXLoop

LoadFragAtAXLoopExit:

POP AX

// Update end of fragged number
MOV AX, [fragmentedSignificandPointer]
MOV [significandEndVariable], AX

RET



// Return 1 in ax if Loaded > frag at ax
CmpLoadedFragToFragAtAXGreaterThan:
RET



fragmentedSignificandPointer: DC.W 0x0
significandStartConstant: DC.W 0x1000
significandEndVariable: DC.W 0x1000
exponentOfFragmentedTwosCompliment: DC.W 0x0
signOfFragmented: DC.W 0x0

immutableFragCopyStartPointer: DC.W 0x0
immutableFragCopyLength: DC.W 0x0

TempAddFragToOtherFragPtrInBXLengthInAXIteration: DC.W 0x0
MulFragmentedNumberByTenIterations: DC.W 0x0

lastCharX: DC.W 0x0

operator: DC.W 0x0

taaa: DC.W 0xFF
tana: DC.W 0xFF
taba: DC.W 0xFF
tada: DC.W 0xFF
taea: DC.W 0xFF

unexpectedError: DC.W 'A'
unexpectedError1: DC.W 'n'
unexpectedError2: DC.W ' '
unexpectedError3: DC.W 'u'
unexpectedError4: DC.W 'n'
unexpectedError5: DC.W 'e'
unexpectedError6: DC.W 'x'
unexpectedError7: DC.W 'p'
unexpectedError8: DC.W 'e'
unexpectedError9: DC.W 'c'
unexpectedError10: DC.W 't'
unexpectedError11: DC.W 'e'
unexpectedError12: DC.W 'd'
unexpectedError13: DC.W ' '
unexpectedError14: DC.W 'e'
unexpectedError15: DC.W 'r'
unexpectedError16: DC.W 'r'
unexpectedError17: DC.W 'o'
unexpectedError18: DC.W 'r'
unexpectedError19: DC.W ' '
unexpectedError20: DC.W 'o'
unexpectedError21: DC.W 'c'
unexpectedError22: DC.W 'c'
unexpectedError23: DC.W 'u'
unexpectedError24: DC.W 'r'
unexpectedError25: DC.W 'e'
unexpectedError26: DC.W 'd'
unexpectedError27: DC.W ' '
unexpectedError28: DC.W ')'
unexpectedError29: DC.W ':'
unexpectedError30: DC.W 0xA
unexpectedError31: DC.W 0xFF


unrecognisedOperator: DC.W 'U'
unrecognisedOperator1: DC.W 'n'
unrecognisedOperator2: DC.W 'r'
unrecognisedOperator3: DC.W 'e'
unrecognisedOperator4: DC.W 'c'
unrecognisedOperator5: DC.W 'o'
unrecognisedOperator6: DC.W 'g'
unrecognisedOperator7: DC.W 'n'
unrecognisedOperator8: DC.W 'i'
unrecognisedOperator9: DC.W 's'
unrecognisedOperator10: DC.W 'e'
unrecognisedOperator11: DC.W 'd'
unrecognisedOperator12: DC.W ' '
unrecognisedOperator13: DC.W 'o'
unrecognisedOperator14: DC.W 'p'
unrecognisedOperator15: DC.W 'e'
unrecognisedOperator16: DC.W 'r'
unrecognisedOperator17: DC.W 'a'
unrecognisedOperator18: DC.W 't'
unrecognisedOperator19: DC.W 'o'
unrecognisedOperator20: DC.W 'r'
unrecognisedOperator21: DC.W '.'
unrecognisedOperator22: DC.W 0xA
unrecognisedOperator23: DC.W 0xFF

enterExpressionPrompt: DC.W 'P'
enterExpressionPrompt1: DC.W 'l'
enterExpressionPrompt2: DC.W 'e'
enterExpressionPrompt3: DC.W 'a'
enterExpressionPrompt4: DC.W 's'
enterExpressionPrompt5: DC.W 'e'
enterExpressionPrompt6: DC.W ' '
enterExpressionPrompt7: DC.W 'e'
enterExpressionPrompt8: DC.W 'n'
enterExpressionPrompt9: DC.W 't'
enterExpressionPrompt10: DC.W 'e'
enterExpressionPrompt11: DC.W 'r'
enterExpressionPrompt12: DC.W ' '
enterExpressionPrompt13: DC.W 'a'
enterExpressionPrompt14: DC.W 'n'
enterExpressionPrompt15: DC.W ' '
enterExpressionPrompt16: DC.W 'e'
enterExpressionPrompt17: DC.W 'x'
enterExpressionPrompt18: DC.W 'p'
enterExpressionPrompt19: DC.W 'r'
enterExpressionPrompt20: DC.W 'e'
enterExpressionPrompt21: DC.W 's'
enterExpressionPrompt22: DC.W 's'
enterExpressionPrompt23: DC.W 'i'
enterExpressionPrompt24: DC.W 'o'
enterExpressionPrompt25: DC.W 'n'
enterExpressionPrompt26: DC.W ' '
enterExpressionPrompt27: DC.W 't'
enterExpressionPrompt28: DC.W 'h'
enterExpressionPrompt29: DC.W 'e'
enterExpressionPrompt30: DC.W ' '
enterExpressionPrompt31: DC.W 'f'
enterExpressionPrompt32: DC.W 'o'
enterExpressionPrompt33: DC.W 'r'
enterExpressionPrompt34: DC.W 'm'
enterExpressionPrompt35: DC.W 'a'
enterExpressionPrompt36: DC.W 't'
enterExpressionPrompt37: DC.W 0xA
enterExpressionPrompt38: DC.W 'a'
enterExpressionPrompt39: DC.W '+'
enterExpressionPrompt40: DC.W 'b'
enterExpressionPrompt41: DC.W '='
enterExpressionPrompt62: DC.W 0xA
enterExpressionPrompt63: DC.W 0xFF