start:
MOV AX, 0xA
MOV BX, 0x0
CALL AddAXToFragmentedNumberOffsettPointerBX
CALL MulFragmentedNumberByTen
CALL MulFragmentedNumberByTen
CALL MulFragmentedNumberByTen
CALL MulFragmentedNumberByTen
CALL MulFragmentedNumberByTen
CALL MulFragmentedNumberByTen
CALL MulFragmentedNumberByTen
CALL MulFragmentedNumberByTen
CALL MulFragmentedNumberByTen
MOV AX, 0x9
MOV BX, 0x0
CALL AddAXToFragmentedNumberOffsettPointerBX
MOV AX, 0x1
MOV BX, 0x0
CALL AddAXToFragmentedNumberOffsettPointerBX
HALT

HALT

MOV AX, taaa
MOV BX, 0x5
CALL AddFragToOtherFragPtrInAXLengthInBX
MOV AX, taaa
MOV BX, 0x5
CALL AddFragToOtherFragPtrInAXLengthInBX
CALL CopyFragmentedNumber
MOV AX, [immutableFragCopyStartPointer]
MOV BX, [immutableFragCopyLength]
INC BX
CALL AddFragToOtherFragPtrInAXLengthInBX
CALL GetFragmentedNumberLengthInMemoryIntoAX
MOV BX, [immutableFragCopyLength]
HALT



// Must ensure this function correctly updates the length of fragmented nubmer
AddAXToFragmentedNumberOffsettPointerBX:

PUSH AX
PUSH BX
CALL ResetSignificandPointerToStart
MOV AX, [fragmentedSignificandPointer]
POP BX 
ADD AX, BX
MOV [fragmentedSignificandPointer], AX
POP AX

AddAXToFragmentedNumberLoop:

CALL SplitAX

PUSH AX

MOV AX, [fragmentedSignificandPointer]
MOV AX, [AX]
ADD AX, BX

CALL SplitAX

PUSH AX

MOV AX, [fragmentedSignificandPointer]
MOV [AX], BX

POP AX
POP BX

ADD AX, BX
CALL IncrementPointerBX

CMP AX, 0x0
JNE AddAXToFragmentedNumberLoop

MOV AX, [fragmentedSignificandPointer]
MOV [significandEndVariable], AX

RET



MulFragmentedNumberByTen:

CALL ResetSignificandPointerToStart
MOV BX, 0x0
PUSH BX

MulFragmentedNumberByTenLoop:

MOV AX, [fragmentedSignificandPointer]
MOV AX, [AX]
MUL AX, 0xA
POP BX
ADD AX, BX

CALL SplitAX
PUSH AX

MOV AX, [fragmentedSignificandPointer]
MOV [AX], BX

CALL IncrementPointerBX

MOV AX, [fragmentedSignificandPointer]
MOV BX, [significandEndVariable]
INC BX
CMP AX, BX
JL MulFragmentedNumberByTenLoop
MOV [significandEndVariable], AX
POP AX
RET



DivFragmentedNumberByTenRemInAX:

CALL ResetSignificandPointerToEnd
MOV BX, 0x0
PUSH BX

DivFragmentedNumberByTenRemInAXLoop:

MOV AX, [fragmentedSignificandPointer]
MOV AX, [AX]

POP BX
MUL BX, 0x10
MUL BX, 0x10
ADD AX, BX
MOV BX, AX

DIV AX, 0xA
MOD BX, 0xA
PUSH BX

MOV BX, [fragmentedSignificandPointer]
MOV [BX], AX

CALL DecrementPointerBX

MOV AX, [fragmentedSignificandPointer]
MOV BX, [significandStartConstant]
CMP AX, BX
JGE DivFragmentedNumberByTenRemInAXLoop

POP AX
RET



// Untested takes pointer to start of a fragmented number and adds it to the currently loaded fragmented number
AddFragToOtherFragPtrInAXLengthInBX:

// Reset iteration counter to 0 while maintaining AX
PUSH AX
MOV AX, 0x0
MOV [TempAddFragToOtherFragPtrInBXLengthInAXIteration], AX
POP AX

// Convert length to end address of number, Decrement BX as 0 counts as one
ADD BX, AX

AddFragToOtherFragPtrInAXLengthInBXLoop:

// Store pointer and end address for loop end condition
PUSH AX
PUSH BX

// Add current fragment to loaded fragment
MOV AX, [AX]
MOV BX, [TempAddFragToOtherFragPtrInBXLengthInAXIteration]
CALL AddAXToFragmentedNumberOffsettPointerBX

// Increment interation counter
MOV BX, [TempAddFragToOtherFragPtrInBXLengthInAXIteration]
INC BX
MOV [TempAddFragToOtherFragPtrInBXLengthInAXIteration], BX

// Retrieve pointer and end address
POP BX
POP AX
// Increment pointer
INC AX
// Check if pointer is at end of number
CMP AX, BX

JL AddFragToOtherFragPtrInAXLengthInBXLoop

RET



// Use variable to access location of copied number, COPPIED NUMBER IS IMMUTABLE
CopyFragmentedNumber:

CALL ResetSignificandPointerToStart
CALL GetFragmentedNumberLengthInMemoryIntoAX
MOV [immutableFragCopyLength], BX
MOV BX, [fragmentedSignificandPointer]
SUB BX, AX
DEC BX
MOV AX, BX
MOV [immutableFragCopyStartPointer], AX
// AX Contains start of the IMMUTABLE copy

CopyFragmentedNumberLoop:

MOV BX, [fragmentedSignificandPointer]
MOV BX, [BX]
MOV [AX], BX
INC AX

CALL IncrementPointerBX

MOV BX, [significandStartConstant]
CMP AX, BX 
JL CopyFragmentedNumberLoop

PUSH AX
Call GetFragmentedNumberLengthInMemoryIntoAX
POP BX
SUB BX, AX
DEC BX

RET



GetFragmentedNumberLengthInMemoryIntoAX:

MOV AX, [significandStartConstant]
MOV BX, [significandEndVariable]
SUB BX, AX
MOV AX, BX

RET



ResetSignificandPointerToStart:
MOV BX, [significandStartConstant]
MOV [fragmentedSignificandPointer], BX
RET



ResetSignificandPointerToEnd:
MOV BX, [significandEndVariable]
MOV [fragmentedSignificandPointer], BX
RET



IncrementPointerBX:
MOV BX, [fragmentedSignificandPointer]
INC BX
MOV [fragmentedSignificandPointer], BX
RET



DecrementPointerBX:
MOV BX, [fragmentedSignificandPointer]
DEC BX
MOV [fragmentedSignificandPointer], BX
RET

NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP



SplitAX:

MOV BX, AX

//BX
PUSH AX
MOV AX, 0x00FF
AND BX, AX
POP AX

//AX
SUB AX, BX
QSR AX
QSR AX

// WASP SHR BUG FIX START
PUSH BX
MOV BX, 0x00FF
AND AX, BX
POP BX
// WASP SHR BUG FIX END
// Result, AX contains 0x**00 >> 8, BX contains 0x00** 
RET



// Reads next char, ignores enter
ReadNext:

// Wait for ready flag
MOV AX, [0x00F5]
CMP AX, 0x0
JEQ ReadNext

// Read char
MOV AX, [0x00F3]

// Switch ready flag
MOV BX, 0x00F5
MOV [BX], 0x0

MOV BX, AX

// Ensure character is not enter
CMP BX, 0xA
JEQ ReadNext

// Check if last two characters are xx
CMP BX, 'x'
JNE NotX
// IF X

// Halt IF LastCharX
MOV BX, [lastCharX]
CMP BX, 0x1
JNE NotLastCharX
HALT
NotLastCharX:

// Update LastCharX flag
MOV BX, 0x1
MOV [lastCharX], BX

RET

// ELSE reset lastCharX flag then return
NotX:
MOV BX, 0x0
MOV [lastCharX], BX

RET



InputNumberToFrag:

CALL ReadNext

PUSH AX
CALL IsNumeric 
CMP AX, 0x0
JEQ IfNotNumeric
POP AX

// Convert to numerical value
PUSH AX
CALL MulFragmentedNumberByTen
POP AX
SUB AX, '0'
MOV BX, 0x0
CALL AddAXToFragmentedNumberOffsettPointerBX

IfNotNumeric:
CMP AX, '='
JEQ Return

JMP InputNumberToFrag



// Input in AX bool return in AX
IsNumeric:

CMP AX, '0'
JGE MoreThanOrEqualToZero
MOV AX, 0x0
RET
MoreThanOrEqualToZero:

MOV BX, '9'
CMP BX, AX
JGE LessThanOrEqualToNine
MOV AX, 0x0
RET
LessThanOrEqualToNine:

MOV AX, 0x1

RET


Return:
RET



fragmentedSignificandPointer: DC.W 0x0
significandStartConstant: DC.W 0x1000
significandEndVariable: DC.W 0x0
exponentOfFragmentedTwosCompliment: DC.W 0x0
signOfFragmented: DC.W 0x0

immutableFragCopyStartPointer: DC.W 0x0
immutableFragCopyLength: DC.W 0x0

TempAddFragToOtherFragPtrInBXLengthInAXIteration: DC.W 0x0

lastCharX: DC.W 0x0

taaa: DC.W 0xFF
tana: DC.W 0xFF
taba: DC.W 0xFF
tada: DC.W 0xFF
taea: DC.W 0xFF
