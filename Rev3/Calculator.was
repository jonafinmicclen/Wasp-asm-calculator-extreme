start:

CALL InputNumberToFrag
HALT
MOV AX, 0x1
CALL PushDigitInAXIntoFrag
MOV AX, 0x6
CALL PushDigitInAXIntoFrag
MOV AX, 0x7
CALL PushDigitInAXIntoFrag
MOV AX, 0x7
CALL PushDigitInAXIntoFrag
MOV AX, 0x7
CALL PushDigitInAXIntoFrag
MOV AX, 0x2
CALL PushDigitInAXIntoFrag
MOV AX, 0x1
CALL PushDigitInAXIntoFrag
MOV AX, 0x5
CALL PushDigitInAXIntoFrag

HALT

MOV AX, 0x5
PUSH AX
CALL MulFragmentedNumberByTen
POP AX
MOV BX, 0x0
CALL AddAXToFragmentedNumberOffsettPointerBX



HALT



HALT

HALT

MOV AX, taaa
MOV BX, 0x5
CALL AddFragToOtherFragPtrInAXLengthInBX
MOV AX, taaa
MOV BX, 0x5
CALL AddFragToOtherFragPtrInAXLengthInBX
CALL CopyFragmentedNumber
MOV AX, [immutableFragCopyStartPointer]
MOV BX, [immutableFragCopyLength]
INC BX
CALL AddFragToOtherFragPtrInAXLengthInBX
CALL GetFragmentedNumberLengthInMemoryIntoAX
MOV BX, [immutableFragCopyLength]
HALT



// Must ensure this function correctly updates the length of fragmented nubmer
AddAXToFragmentedNumberOffsettPointerBX:

PUSH AX
PUSH BX
CALL ResetSignificandPointerToStart
MOV AX, [fragmentedSignificandPointer]
POP BX 
ADD AX, BX
MOV [fragmentedSignificandPointer], AX
POP AX

AddAXToFragmentedNumberLoop:

CALL SplitAX

PUSH AX

MOV AX, [fragmentedSignificandPointer]
MOV AX, [AX]
ADD AX, BX

CALL SplitAX

PUSH AX

MOV AX, [fragmentedSignificandPointer]
MOV [AX], BX

POP AX
POP BX

ADD AX, BX
CALL IncrementPointerBX

CMP AX, 0x0
JNE AddAXToFragmentedNumberLoop

// Check if pointer is more than end first
MOV AX, [fragmentedSignificandPointer]
DEC AX
MOV BX, [significandEndVariable]
CMP AX, BX
JL DontUpdateEndVar
MOV [significandEndVariable], AX
DontUpdateEndVar:

RET



// This entire function is trash
MulFragmentedNumberByTen:

// Initialise iterations counter
MOV AX, 0x0
MOV [MulFragmentedNumberByTenIterations], AX

// Copy the number to multiply segments by ten
CALL CopyFragmentedNumber
// Reset number to 0 to add products into
CALL ResetFragmentedNumberToZero


// Find start and end address of fragmented number
MOV AX, [immutableFragCopyStartPointer]
MOV BX, [immutableFragCopyLength]
ADD BX, AX
// AX Contains pointer to start BX contains pointer to end

MulFragmentedNumberByTenLoop:

// Save pointer and end address
PUSH AX
PUSH BX

MOV AX, [AX]
MUL AX, 0xA
MOV BX, [MulFragmentedNumberByTenIterations]
CALL AddAXToFragmentedNumberOffsettPointerBX

// Increase counter
MOV AX, [MulFragmentedNumberByTenIterations]
INC AX
MOV [MulFragmentedNumberByTenIterations], AX

// Get Pointer and end address
POP BX
POP AX
// Increment Pointer and continue if not out of bounds
INC AX
CMP BX, AX
JGE MulFragmentedNumberByTenLoop

RET



DivFragmentedNumberByTenRemInAX:

CALL ResetSignificandPointerToEnd
MOV BX, 0x0
PUSH BX

DivFragmentedNumberByTenRemInAXLoop:

MOV AX, [fragmentedSignificandPointer]
MOV AX, [AX]

POP BX
MUL BX, 0x10
MUL BX, 0x10
ADD AX, BX
MOV BX, AX

DIV AX, 0xA
MOD BX, 0xA
PUSH BX

MOV BX, [fragmentedSignificandPointer]
MOV [BX], AX

CALL DecrementPointerBX

MOV AX, [fragmentedSignificandPointer]
MOV BX, [significandStartConstant]
CMP AX, BX
JGE DivFragmentedNumberByTenRemInAXLoop

POP AX
RET



// Untested takes pointer to start of a fragmented number and adds it to the currently loaded fragmented number
AddFragToOtherFragPtrInAXLengthInBX:

// Reset iteration counter to 0 while maintaining AX
PUSH AX
MOV AX, 0x0
MOV [TempAddFragToOtherFragPtrInBXLengthInAXIteration], AX
POP AX

// Convert length to end address of number, Decrement BX as 0 counts as one
ADD BX, AX

AddFragToOtherFragPtrInAXLengthInBXLoop:

// Store pointer and end address for loop end condition
PUSH AX
PUSH BX

// Add current fragment to loaded fragment
MOV AX, [AX]
MOV BX, [TempAddFragToOtherFragPtrInBXLengthInAXIteration]
CALL AddAXToFragmentedNumberOffsettPointerBX

// Increment interation counter
MOV BX, [TempAddFragToOtherFragPtrInBXLengthInAXIteration]
INC BX
MOV [TempAddFragToOtherFragPtrInBXLengthInAXIteration], BX

// Retrieve pointer and end address
POP BX
POP AX
// Increment pointer
INC AX
// Check if pointer is at end of number
CMP AX, BX

JL AddFragToOtherFragPtrInAXLengthInBXLoop

RET



// Use variable to access location of copied number, COPPIED NUMBER IS IMMUTABLE
CopyFragmentedNumber:

CALL ResetSignificandPointerToStart
CALL GetFragmentedNumberLengthInMemoryIntoAX
MOV [immutableFragCopyLength], BX
MOV BX, [fragmentedSignificandPointer]
SUB BX, AX
DEC BX
MOV AX, BX
MOV [immutableFragCopyStartPointer], AX
// AX Contains start of the IMMUTABLE copy

CopyFragmentedNumberLoop:

MOV BX, [fragmentedSignificandPointer]
MOV BX, [BX]
MOV [AX], BX
INC AX

CALL IncrementPointerBX

MOV BX, [significandStartConstant]
CMP AX, BX 
JL CopyFragmentedNumberLoop

PUSH AX
Call GetFragmentedNumberLengthInMemoryIntoAX
POP BX
SUB BX, AX
DEC BX

RET




NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP


GetFragmentedNumberLengthInMemoryIntoAX:

MOV AX, [significandStartConstant]
MOV BX, [significandEndVariable]
SUB BX, AX
MOV AX, BX

RET



ResetSignificandPointerToStart:
MOV BX, [significandStartConstant]
MOV [fragmentedSignificandPointer], BX
RET



ResetSignificandPointerToEnd:
MOV BX, [significandEndVariable]
MOV [fragmentedSignificandPointer], BX
RET



IncrementPointerBX:
MOV BX, [fragmentedSignificandPointer]
INC BX
MOV [fragmentedSignificandPointer], BX
RET



DecrementPointerBX:
MOV BX, [fragmentedSignificandPointer]
DEC BX
MOV [fragmentedSignificandPointer], BX
RET




SplitAX:

MOV BX, AX

//BX
PUSH AX
MOV AX, 0x00FF
AND BX, AX
POP AX

//AX
SUB AX, BX
QSR AX
QSR AX

// WASP SHR BUG FIX START
PUSH BX
MOV BX, 0x00FF
AND AX, BX
POP BX
// WASP SHR BUG FIX END
// Result, AX contains 0x**00 >> 8, BX contains 0x00** 
RET



// Reads next char, ignores enter
ReadNext:

// Wait for ready flag
MOV AX, [0x00F5]
CMP AX, 0x0
JEQ ReadNext

// Read char
MOV AX, [0x00F3]

// Switch ready flag
MOV BX, 0x00F5
MOV [BX], 0x0

MOV BX, AX

// Ensure character is not enter
CMP BX, 0xA
JEQ ReadNext

// Check if last two characters are xx
CMP BX, 'x'
JNE NotX
// IF X

// Halt IF LastCharX
MOV BX, [lastCharX]
CMP BX, 0x1
JNE NotLastCharX
HALT
NotLastCharX:

// Update LastCharX flag
MOV BX, 0x1
MOV [lastCharX], BX

RET

// ELSE reset lastCharX flag then return
NotX:
MOV BX, 0x0
MOV [lastCharX], BX

RET



InputNumberToFrag:

CALL ReadNext
PUSH AX

CALL IsAXNumeric
CMP AX, 0x0
JEQ IfNotNumeric

POP AX
SUB AX, '0'
CALL PushDigitInAXIntoFrag

JMP InputNumberToFrag

IfNotNumeric:
POP AX
CMP AX, '='
JEQ Return

JMP InputNumberToFrag



// Input in AX bool return in AX
IsAXNumeric:

CMP AX, '0'
JGE MoreThanOrEqualToZero
MOV AX, 0x0
RET
MoreThanOrEqualToZero:

MOV BX, '9'
CMP BX, AX
JGE LessThanOrEqualToNine
MOV AX, 0x0
RET
LessThanOrEqualToNine:

MOV AX, 0x1

RET


PushDigitInAXIntoFrag:
PUSH AX
CALL MulFragmentedNumberByTen
POP AX
MOV BX, 0x0
CALL AddAXToFragmentedNumberOffsettPointerBX
RET


Return:
RET

ResetFragmentedNumberToZero:

MOV AX, [significandStartConstant]
MOV BX, [significandEndVariable]

ResetFragmentedNumberToZeroLoop:

MOV [AX], 0x0
INC AX
CMP BX, AX
JGE ResetFragmentedNumberToZeroLoop

MOV BX, [significandStartConstant]
MOV AX, significandEndVariable
MOV [AX], BX

RET



fragmentedSignificandPointer: DC.W 0x0
significandStartConstant: DC.W 0x1000
significandEndVariable: DC.W 0x1000
exponentOfFragmentedTwosCompliment: DC.W 0x0
signOfFragmented: DC.W 0x0

immutableFragCopyStartPointer: DC.W 0x0
immutableFragCopyLength: DC.W 0x0

TempAddFragToOtherFragPtrInBXLengthInAXIteration: DC.W 0x0
MulFragmentedNumberByTenIterations: DC.W 0x0

lastCharX: DC.W 0x0

taaa: DC.W 0xFF
tana: DC.W 0xFF
taba: DC.W 0xFF
tada: DC.W 0xFF
taea: DC.W 0xFF
