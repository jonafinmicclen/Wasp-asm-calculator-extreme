start:
CALL ResetFragmentedNumberToZero
CALL InputNumberToFrag

MOV AX, 0x200
CALL CopyFragmentedNumberToAddressInAXEndFlagged

CALL ResetFragmentedNumberToZero
CALL InputNumberToFrag

MOV AX, 0x200
CALL AddFragAtAXToFrag

CALL PrintFragmentedNumber

JMP start



// If any bugs happen make sure a function using the pointer doesn't call another also using the pointer

// Must ensure this function correctly updates the length of fragmented nubmer, I think it does now that i fixed it ..
AddAXToFragmentedNumberOffsettPointerBX:

PUSH AX
PUSH BX
CALL ResetSignificandPointerToStart
MOV AX, [fragmentedSignificandPointer]
POP BX 
ADD AX, BX
MOV [fragmentedSignificandPointer], AX
POP AX

AddAXToFragmentedNumberLoop:

CALL SplitAX

PUSH AX

MOV AX, [fragmentedSignificandPointer]
MOV AX, [AX]
ADD AX, BX

CALL SplitAX

PUSH AX

MOV AX, [fragmentedSignificandPointer]
MOV [AX], BX

POP AX
POP BX

ADD AX, BX
CALL IncrementPointerBX

CMP AX, 0x0
JNE AddAXToFragmentedNumberLoop

// Check if pointer is more than end first
MOV AX, [fragmentedSignificandPointer]
DEC AX
MOV BX, [significandEndVariable]
CMP AX, BX
JL DontUpdateEndVar
MOV [significandEndVariable], AX
DontUpdateEndVar:

RET



// This entire function is trash
MulFragmentedNumberByTen:

// Initialise iterations counter
MOV AX, 0x0
MOV [MulFragmentedNumberByTenIterations], AX

// Copy the number to multiply segments by ten
CALL CopyFragmentedNumber
// Reset number to 0 to add products into
CALL ResetFragmentedNumberToZero


// Find start and end address of fragmented number
MOV AX, [immutableFragCopyStartPointer]
MOV BX, [immutableFragCopyLength]
ADD BX, AX
// AX Contains pointer to start BX contains pointer to end

MulFragmentedNumberByTenLoop:

// Save pointer and end address
PUSH AX
PUSH BX

MOV AX, [AX]
MUL AX, 0xA
MOV BX, [MulFragmentedNumberByTenIterations]
CALL AddAXToFragmentedNumberOffsettPointerBX

// Increase counter
MOV AX, [MulFragmentedNumberByTenIterations]
INC AX
MOV [MulFragmentedNumberByTenIterations], AX

// Get Pointer and end address
POP BX
POP AX
// Increment Pointer and continue if not out of bounds
INC AX
CMP BX, AX
JGE MulFragmentedNumberByTenLoop

RET



DivFragmentedNumberByTenRemInAX:

CALL ResetSignificandPointerToEnd
MOV BX, 0x0
PUSH BX

DivFragmentedNumberByTenRemInAXLoop:

MOV AX, [fragmentedSignificandPointer]
MOV AX, [AX]

POP BX
MUL BX, 0x10
MUL BX, 0x10
ADD AX, BX
MOV BX, AX

DIV AX, 0xA
MOD BX, 0xA
PUSH BX

MOV BX, [fragmentedSignificandPointer]
MOV [BX], AX

CALL DecrementPointerBX

MOV AX, [fragmentedSignificandPointer]
MOV BX, [significandStartConstant]
CMP AX, BX
JGE DivFragmentedNumberByTenRemInAXLoop

POP AX
RET



// Untested takes pointer to start of a fragmented number and adds it to the currently loaded fragmented number
AddFragToOtherFragPtrInAXLengthInBX:

// Reset iteration counter to 0 while maintaining AX
PUSH AX
MOV AX, 0x0
MOV [TempAddFragToOtherFragPtrInBXLengthInAXIteration], AX
POP AX

// Convert length to end address of number, Decrement BX as 0 counts as one
ADD BX, AX

AddFragToOtherFragPtrInAXLengthInBXLoop:

// Store pointer and end address for loop end condition
PUSH AX
PUSH BX

// Add current fragment to loaded fragment
MOV AX, [AX]
MOV BX, [TempAddFragToOtherFragPtrInBXLengthInAXIteration]
CALL AddAXToFragmentedNumberOffsettPointerBX

// Increment interation counter
MOV BX, [TempAddFragToOtherFragPtrInBXLengthInAXIteration]
INC BX
MOV [TempAddFragToOtherFragPtrInBXLengthInAXIteration], BX

// Retrieve pointer and end address
POP BX
POP AX
// Increment pointer
INC AX
// Check if pointer is at end of number
CMP AX, BX

JL AddFragToOtherFragPtrInAXLengthInBXLoop

RET



// Use variable to access location of copied number, COPPIED NUMBER IS IMMUTABLE
CopyFragmentedNumber:

CALL ResetSignificandPointerToStart
CALL GetFragmentedNumberLengthInMemoryIntoBX
MOV [immutableFragCopyLength], BX
MOV BX, [fragmentedSignificandPointer]
SUB BX, AX
DEC BX
MOV AX, BX
MOV [immutableFragCopyStartPointer], AX
// AX Contains start of the IMMUTABLE copy

CopyFragmentedNumberLoop:

MOV BX, [fragmentedSignificandPointer]
MOV BX, [BX]
MOV [AX], BX
INC AX

CALL IncrementPointerBX

MOV BX, [significandStartConstant]
CMP AX, BX 
JL CopyFragmentedNumberLoop

PUSH AX
Call GetFragmentedNumberLengthInMemoryIntoBX
POP BX
SUB BX, AX
DEC BX

RET


// Use variable to access location of copied number, COPPIED NUMBER IS IMMUTABLE
CopyFragmentedNumberToAddressInAXEndFlagged:

PUSH AX
CALL ResetSignificandPointerToStart
CALL GetFragmentedNumberLengthInMemoryIntoBX
POP AX
ADD BX, AX

CopyFragmentedNumberToAddressInAXEndFlaggedLoop:
PUSH BX
PUSH AX

MOV BX, [fragmentedSignificandPointer]
MOV BX, [BX]
MOV [AX], BX

CALL IncrementPointerBX
CALL GetFragmentedNumberLengthInMemoryIntoBX
POP AX
POP BX
INC AX

CMP BX, AX
JGE CopyFragmentedNumberToAddressInAXEndFlaggedLoop

// End flag is abcd
MOV [AX], 0xABCD

RET



NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP


GetFragmentedNumberLengthInMemoryIntoBX:

MOV AX, [significandStartConstant]
MOV BX, [significandEndVariable]
SUB BX, AX
MOV AX, BX

RET



ResetSignificandPointerToStart:
MOV BX, [significandStartConstant]
MOV [fragmentedSignificandPointer], BX
RET



ResetSignificandPointerToEnd:
MOV BX, [significandEndVariable]
MOV [fragmentedSignificandPointer], BX
RET



IncrementPointerBX:
MOV BX, [fragmentedSignificandPointer]
INC BX
MOV [fragmentedSignificandPointer], BX
RET



DecrementPointerBX:
MOV BX, [fragmentedSignificandPointer]
DEC BX
MOV [fragmentedSignificandPointer], BX
RET




SplitAX:

MOV BX, AX

//BX
PUSH AX
MOV AX, 0x00FF
AND BX, AX
POP AX

//AX
SUB AX, BX
QSR AX
QSR AX

// WASP SHR BUG FIX START
PUSH BX
MOV BX, 0x00FF
AND AX, BX
POP BX
// WASP SHR BUG FIX END
// Result, AX contains 0x**00 >> 8, BX contains 0x00** 
RET



// Reads next char, ignores enter
ReadNext:

// Wait for ready flag
MOV AX, [0x00F5]
CMP AX, 0x0
JEQ ReadNext

// Read char
MOV AX, [0x00F3]

// Switch ready flag
MOV BX, 0x00F5
MOV [BX], 0x0

MOV BX, AX

// Ensure character is not enter
CMP BX, 0xA
JEQ ReadNext

// Check if last two characters are xx
CMP BX, 'x'
JNE NotX
// IF X

// Halt IF LastCharX
MOV BX, [lastCharX]
CMP BX, 0x1
JNE NotLastCharX
HALT
NotLastCharX:

// Update LastCharX flag
MOV BX, 0x1
MOV [lastCharX], BX

RET

// ELSE reset lastCharX flag then return
NotX:
MOV BX, 0x0
MOV [lastCharX], BX

RET



InputNumberToFrag:

CALL ReadNext
PUSH AX

CALL IsAXNumeric
CMP AX, 0x0
JEQ IfNotNumeric

POP AX
SUB AX, '0'
CALL PushDigitInAXIntoFrag

JMP InputNumberToFrag

IfNotNumeric:
POP AX
CMP AX, '='
JEQ Return

JMP InputNumberToFrag



// Input in AX bool return in AX
IsAXNumeric:

CMP AX, '0'
JGE MoreThanOrEqualToZero
MOV AX, 0x0
RET
MoreThanOrEqualToZero:

MOV BX, '9'
CMP BX, AX
JGE LessThanOrEqualToNine
MOV AX, 0x0
RET
LessThanOrEqualToNine:

MOV AX, 0x1

RET


PushDigitInAXIntoFrag:
PUSH AX
CALL MulFragmentedNumberByTen
POP AX
MOV BX, 0x0
CALL AddAXToFragmentedNumberOffsettPointerBX
RET


Return:
RET

ResetFragmentedNumberToZero:

MOV AX, [significandStartConstant]
MOV BX, [significandEndVariable]

ResetFragmentedNumberToZeroLoop:

MOV [AX], 0x0
INC AX
CMP BX, AX
JGE ResetFragmentedNumberToZeroLoop

MOV BX, [significandStartConstant]
MOV AX, significandEndVariable
MOV [AX], BX

RET



PrintChar:
MOV [0xF0], AX
MOV AX, 0x0001
MOV [0xF2], AX
PrintCharLoop:
MOV AX, [0x00F2]
CMP AX, 0x1
JEQ PrintCharLoop
RET


// Kinda gross use of stack but its perfect
PrintFragmentedNumber:

// This is end flag for printing number
MOV AX, 0xABCD
PUSH AX

PrintFragmentedNumberLoopFirst:

// Div frag by ten and push Remainder
CALL DivFragmentedNumberByTenRemInAX
ADD AX, '0'
PUSH AX

// Increment and end condition
CALL IsFragmentedNumberZero
CMP AX, 0x1
JNE PrintFragmentedNumberLoopFirst

PrintFragmentedNumberLoopSecond:

POP AX
PUSH AX
CALL PrintChar
POP AX
MOV BX, 0xABCD
CMP AX, BX
JNE PrintFragmentedNumberLoopSecond

RET



IsFragmentedNumberZero:

CALL ResetSignificandPointerToStart

IsFragmentedNumberZeroLoop:

MOV BX, [fragmentedSignificandPointer]
MOV AX, [BX]
CMP AX, 0x0
JNE NotZero

CALL IncrementPointerBX
MOV AX, [fragmentedSignificandPointer]
MOV BX, [significandEndVariable]
CMP BX, AX
JGE IsFragmentedNumberZeroLoop

MOV AX, 0x1
RET

NotZero:
MOV AX, 0x0
RET



AddFragAtAXToFrag:

// Ax contains start of frag to add from, end of this frag is indicated by abcd
// BX will be iteration counter
MOV BX, 0x0

AddFragAtAXToFragLoop:

PUSH AX
PUSH BX

MOV AX, [AX]
MOV BX, 0xABCD
CMP AX, BX
JEQ AddFragAtAXToFragLoopEnd

POP BX
PUSH BX

CALL AddAXToFragmentedNumberOffsettPointerBX

POP BX
POP AX

INC AX
INC BX

JMP AddFragAtAXToFragLoop

AddFragAtAXToFragLoopEnd:

//Cleanup stack
POP AX
POP BX

RET




fragmentedSignificandPointer: DC.W 0x0
significandStartConstant: DC.W 0x1000
significandEndVariable: DC.W 0x1000
exponentOfFragmentedTwosCompliment: DC.W 0x0
signOfFragmented: DC.W 0x0

immutableFragCopyStartPointer: DC.W 0x0
immutableFragCopyLength: DC.W 0x0

TempAddFragToOtherFragPtrInBXLengthInAXIteration: DC.W 0x0
MulFragmentedNumberByTenIterations: DC.W 0x0

lastCharX: DC.W 0x0

taaa: DC.W 0xFF
tana: DC.W 0xFF
taba: DC.W 0xFF
tada: DC.W 0xFF
taea: DC.W 0xFF
