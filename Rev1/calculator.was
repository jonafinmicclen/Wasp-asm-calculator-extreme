// MAIN START

MOV AX, 0xAAAA
MOV BX, 0xAAAA
CALL outputBinToDec32bit
HALT

// MAIN END


// FUNCTIONS
// FUNCTION START
hexmulitply:

CALL anbngenerator

MOV BX, [AN00]

MUL AX, BX
MOV [ARG3], AX

MOV AX, [AN01]
MOV BX, [BN00]
MUL AX, BX
MOV [TEMP2], AX
MOV AX, [AN00]
MOV BX, [BN01]
MUL BX, AX
MOV AX, [TEMP2]
ADD AX, BX
MOV [ARG4], AX

MOV AX, [AN01]
MOV BX, [BN01]
MUL AX, BX
MOV [ARG5], AX

CALL combinethree

MOV AX, [RETURN0]
MOV BX, [RETURN1]
QSL BX
QSL BX
ADD AX, BX
MOV [RETURN0], AX
MOV AX, [RETURN2]
MOV BX, [RETURN3]
QSL AX
QSL AX
ADD AX, BX
MOV BX, [RETURN0]
// Print them all here with the hex to dec print function

RET
// hexmulitply END


// Outputs AX contents in Decimal to console only if BX is 0x0000
outputBinToDec:

MOV [nextNumberToConvertBinToDec], AX

// Initialise pointer for array
CALL globalPointerInitialise
CALL globalPointerSetDirectionIncrement

// start of loop, this loop is to fill memory with the digits of the number starting from the last digit.
binToDecFillArrayLoop: 

MOV AX, [nextNumberToConvertBinToDec]
CALL modulusbyten
ADD AX, '0'
CALL globalAXIntoPointer

MOV AX, [nextNumberToConvertBinToDec]
CALL divisionbyten
MOV [nextNumberToConvertBinToDec], AX

CALL globalPointerUpdate

MOV AX, [nextNumberToConvertBinToDec]
CMP AX, 0d10
JGE binToDecFillArrayLoop

// end of loop

ADD AX, '0'
CALL printchar
CALL globalPointerSetDirectionDecrement

// Updating pointer bc last loop increments 1 too many times..
CALL globalPointerUpdate

// start of loop, this loop prints the digits generated by the previous one but in reverse order
binToHexOutputLoop:

CALL globalGetDataAtPointerIntoAX
CALL printchar

CALL globalPointerUpdate

// End condition, could be in function maybe
MOV AX, [GlobalPointer]
MOV BX, GlobalPointerStart
MOV BX, [BX]
CMP AX, BX

JL return

JMP binToHexOutputLoop

// END OF outputBinToDec




// Outputs AX * 0x1000 + BX in decimal to console
outputBinToDec32bit:

MOV [nextNumberToConvertBinToDecLow], AX
MOV [nextNumberToConvertBinToDecHigh], BX

// Initialise pointer for array
CALL globalPointerInitialise
CALL globalPointerSetDirectionIncrement

// start of loop, this loop is to fill memory with the digits of the number starting from the last digit.
binToDecFillArrayLoop32: 

MOV AX, [nextNumberToConvertBinToDecLow]
MOV BX, [nextNumberToConvertBinToDecHigh]

CALL 32bitdivisionbyten
MOV AX, [32divrem]

ADD AX, '0'
CALL globalAXIntoPointer

MOV AX, [nextNumberToConvertBinToDecLow]
MOV BX, [nextNumberToConvertBinToDecHigh]
CALL 32bitdivisionbyten
MOV AX, [nextNumberToConvertBinToDecLow]
MOV BX, [nextNumberToConvertBinToDecHigh]

CALL globalPointerUpdate

MOV AX, [nextNumberToConvertBinToDecLow]
MOV BX, [nextNumberToConvertBinToDecHigh]
ADD AX, BX
CMP AX, 0d10
JGE binToDecFillArrayLoop32

// end of loop

ADD AX, '0'
CALL printchar
CALL globalPointerSetDirectionDecrement

// Updating pointer bc last loop increments 1 too many times..
CALL globalPointerUpdate

// start of loop, this loop prints the digits generated by the previous one but in reverse order
binToHexOutputLoop32:

CALL globalGetDataAtPointerIntoAX
CALL printchar

CALL globalPointerUpdate

// End condition, could be in function maybe
MOV AX, [GlobalPointer]
MOV BX, GlobalPointerStart
MOV BX, [BX]
CMP AX, BX

JL return

JMP binToHexOutputLoop32

// END OF outputBinToDec



takenumericalinput:
MOV AX, 0x0
MOV [takenumericalinputvalue], AX
takenumericalinputloop:
CALL readnext
CMP AX, '.'
JEQ return
SUB AX, '0'
MOV BX, [takenumericalinputvalue]
MUL BX, 0xA
ADD BX, AX
MOV [takenumericalinputvalue], BX
JMP takenumericalinputloop
// END OF takenumericalinput



// Taken from console test
readnext:
readnextloop:
MOV AX, [0x00F5]
CMP AX, 0x0
JEQ readnextloop
MOV AX, [0x00F3]
MOV BX, 0x00F5
MOV [BX], 0x0
RET
// END OF readnext



// Jump to this to use as: if () {return}.
return:
RET
// END OF return



printchar:
MOV [0x00F0], AX
MOV BX, 0x0001
MOV [0xF2], BX
printcharloop:
MOV BX, [0x00F2]
CMP BX, 0x1
JEQ printcharloop
RET
// Prints char in AX



// Do not use this inside a function already using this at some preceeding function call
// Global pointer functions


globalPointerInitialise:
MOV AX, GlobalPointerStart
MOV AX, [AX]
MOV [GlobalPointer], AX
RET

globalGetDataAtPointerIntoAX:
MOV BX, [GlobalPointer]
MOV AX, [BX]
RET

globalPointerSetDirectionIncrement:
MOV BX, 0x0
MOV [GlobalPointerDirection], BX
RET

globalPointerSetDirectionDecrement:
MOV BX, 0x1
MOV [GlobalPointerDirection], BX
RET

globalAXIntoPointer:
MOV BX, [GlobalPointer]
MOV [BX], AX
RET


globalPointerUpdate:

// Check flag decrementing
MOV BX, [GlobalPointerDirection]
CMP BX, 0x0
JEQ GlobalPointerIncrement

MOV AX, [GlobalPointer]
DEC AX
MOV [GlobalPointer], AX

RET

GlobalPointerIncrement:

MOV AX, [GlobalPointer]
INC AX
MOV [GlobalPointer], AX

RET

// Runs function in BX
MaintainAXRegisterFunctionWrapper:
MOV [AXCopyForWrapper], AX
CALL AX
MOV AX, [AXCopyForWrapper]
RET



modulusbyten:
CALL splitvalue
MOD AX, 0d10
MOD BX, 0d10
QSL AX
QSL AX
ADD AX, BX
MOD AX, 0d10
RET

divisionbyten:
CALL splitvalue
MOV [divisionbytentemplow], BX
MOV BX, AX

DIV AX, 0d10
MOV [divisionbytentemphighfinal], AX

MOD BX, 0d10
QSL BX
QSL BX

MOV AX, [divisionbytentemplow]

ADD BX, AX
DIV BX, 0d10

MOV AX, [divisionbytentemphighfinal]
QSL AX
QSL AX

ADD AX, BX

RET



32bitdivisionbyten:

MOV [32divlow], BX

CALL 16bitdivisionbyten
MOV [32divhigh], AX

MOV AX, [32divlow]
QSL BX
QSL BX
MOV [32divrem], BX

CALL splitvalue
MOV [16divlow], BX

MOV BX, [32divrem]
ADD AX, BX

MOV BX, AX
DIV AX, 0d10
MOD BX, 0d10

MOV [TEMP2], AX

MOV AX, [16divlow]
QSL BX
QSL BX
ADD AX, BX

MOV BX, AX
DIV AX, 0d10
MOD BX, 0d10

MOV [32divrem], BX
MOV BX, [TEMP2]
QSL BX
QSL BX
ADD BX, AX

MOV AX, [32divhigh]
MOV [32divlow], BX

RET



16bitdivisionbyten:

CALL splitvalue
MOV [16divhigh], AX
MOV [16divlow], BX

MOV BX, AX
DIV AX, 0d10
MOD BX, 0d10
MOV [16divhigh], AX
// ResultHigh in AX Remainder in BX

MOV AX, [16divlow]
QSL BX
QSL BX
ADD AX, BX

MOV BX, AX
DIV AX, 0d10
MOD BX, 0d10

MOV [16divrem], BX

MOV BX, [16divhigh]
QSL BX
QSL BX
ADD AX, BX
MOV BX, [16divrem]
// Remainder in BX ResultLow in AX

RET



// FUNCTION START
hexadd:

CALL anbngenerator

// This works becuase of the state anbngenerator leaves.
MOV AX, [AN01]
MOV BX, [BN01]
ADD AX, BX

CALL splitvalue

// right result final in temp 1
MOV [TEMP1], BX

MOV BX, [AN00]
ADD AX, BX
MOV BX, [BN00]
ADD AX, BX

MOV BX, [TEMP1]

RET
// hexadd END


// FUNCTION START
// Splits ax and bx into 4 values a0,a1,b0,b1 containing low and high.
anbngenerator:

MOV [TEMP1], BX

CALL splitvalue

MOV [AN00], AX
MOV [AN01], BX

MOV AX, [TEMP1]

CALL splitvalue

MOV [BN00], AX
MOV [BN01], BX

RET
// anbngenerator END

// FUNCTION START
splitvalue:

MOV BX, AX

//BX
MOV [AXCOPY], AX
MOV AX, 0x00FF
AND BX, AX
MOV AX, [AXCOPY]

//AX
QSR AX
CALL waspSHRfixAX
QSR AX
CALL waspSHRfixAX

RET
// Result, AX contains 0x**00 >> 8, BX contains 0x00** 
// splitvalue END



// FUNCTION START
splitlast:

MOV BX, 0xFFF0
MOV [AXCOPY], AX
AND AX, BX
MOV BX, [AXCOPY]
SUB BX, AX
QSR AX
CALL waspSHRfixAX

RET
// Result, AX: 0x***0 > 4, BX 0x000*
// splitlast END

waspSHRfixAX:
MOV [BXCOPY], BX
MOV BX, 0x0FFF
AND AX, BX
MOV BX, [BXCOPY]
RET

combinethree:
MOV AX, [ARG5]
CALL splitvalue
MOV [RETURN0], BX
MOV BX, [ARG4]
CALL hexadd
MOV [RETURN1], BX
MOV BX, [ARG3]
CALL hexadd
MOV [RETURN2], AX
MOV [RETURN3], BX
RET




// Variables
takenumericalinputvalue: DC.W 0X1FFF
GlobalPointerDirection: DC.W 0X1FFE
TEMP1: DC.W 0X1FFD
RETURN3: DC.W 0X1FFC
16divhigh: DC.W 0X1FFB
VALUEA: DC.W 0X1FF9
AN00: DC.W 0X1FF8
AXCOPY: DC.W 0X1FF7
AN01: DC.W 0X1FF6
AXCopyForWrapper: DC.W 0X1FF5
OPERATOR: DC.W 0X1FF4
ARG3: DC.W 0X1FF3
32divlow: DC.W 0X1FF2
copy: DC.W 0X1FF1
16divrem: DC.W 0X1FF0
16divlow: DC.W 0X1FEF
ARG5: DC.W 0X1FEE
BN00: DC.W 0X1FED
nextNumberToConvertBinToDec: DC.W 0X1FEC
TEMP2: DC.W 0X1FEB
BXCOPY: DC.W 0X1FEA
RETURN0: DC.W 0X1FE9
GlobalPointer: DC.W 0X1FE8
VALUEB: DC.W 0X1FE7
FUNCPTR: DC.W 0X1FE6
divisionbytentemplow: DC.W 0X1FE5
RETURN2: DC.W 0X1FE4
TEMP4: DC.W 0X1FE3
divisionbytentemphighfinal: DC.W 0X1FE2
ARG4: DC.W 0X1FE1
32divhigh: DC.W 0X1FE0
TEMP3: DC.W 0X1FDF
RETURN1: DC.W 0X1FDE
BN01: DC.W 0X1FDD
32divrem: DC.W 0X1FDC
nextNumberToConvertBinToDecLow: DC.W 0x1FDB
nextNumberToConvertBinToDecHigh: DC.W 0x1FDA

// Constants
GlobalPointerStart: DC.W 0X1FD0