// MAx tested 4000 * 4000 = 16000000

mainstart:

MOV AX, 0x0
MOV BX, 0x0

MOV BX, text0
CALL outputTextFromMemory

CALL takeInput

MOV AX, [operandA]
MOV BX, [operandB]

// Print what they wrote before the answer
MOV AX, 0x0
MOV BX, [operandA]
CALL outputBinToDec32
MOV AX, [operator]
CALL printchar
MOV AX, 0x0
MOV BX, [operandB]
CALL outputBinToDec32
MOV AX, '='
CALL printchar

// Calculate answer and output
MOV AX, [operandA]
MOV BX, [operandB]
CALL hexmulitply
CALL outputBinToDec32

// Leave two spaces for next one
MOV AX, 0xA
CALL printchar
MOV AX, 0xA
CALL printchar

JMP mainstart
HALT



// Outputs AX contents in Decimal to console
outputBinToDec:

MOV [nextNumberToConvertBinToDec], AX

// Initialise pointer for array
CALL globalPointerInitialise
CALL globalPointerSetDirectionIncrement

// start of loop, this loop is to fill memory with the digits of the number starting from the last digit.
binToDecFillArrayLoop: 

MOV AX, [nextNumberToConvertBinToDec]
CALL modulusbyten
ADD AX, '0'
CALL globalAXIntoPointer

MOV AX, [nextNumberToConvertBinToDec]
CALL divisionbyten
MOV [nextNumberToConvertBinToDec], AX

CALL globalPointerUpdate

MOV AX, [nextNumberToConvertBinToDec]
CMP AX, 0d10
JGE binToDecFillArrayLoop

// end of loop

ADD AX, '0'
CALL printchar
CALL globalPointerSetDirectionDecrement

// Updating pointer bc last loop increments 1 too many times..
CALL globalPointerUpdate

// start of loop, this loop prints the digits generated by the previous one but in reverse order
binToHexOutputLoop:

CALL globalGetDataAtPointerIntoAX
CALL printchar

CALL globalPointerUpdate

// End condition, could be in function maybe
MOV AX, [GlobalPointer]
MOV BX, GlobalPointerStart
MOV BX, [BX]
CMP AX, BX

JL return

JMP binToHexOutputLoop

// END OF outputBinToDec


hexadd:

CALL anbngenerator

// This works becuase of the state anbngenerator leaves.
MOV AX, [AN01]
MOV BX, [BN01]
ADD AX, BX

CALL splitvalue

// right result final in temp 1
MOV [TEMP1], BX

MOV BX, [AN00]
ADD AX, BX
MOV BX, [BN00]
ADD AX, BX

MOV BX, [TEMP1]

RET
// hexadd END


combinethree:
MOV AX, [ARG5]
CALL splitvalue
MOV [RETURN0], BX
MOV BX, [ARG4]
CALL hexadd
MOV [RETURN1], BX
MOV BX, [ARG3]
CALL hexadd
MOV [RETURN2], AX
MOV [RETURN3], BX
RET


takenumericalinput:
MOV AX, 0x0
MOV BX, 0x0
MOV [takenumericalinputvalue], BX
takenumericalinputloop:
CALL readnext

// Put delimiters here
MOV [operatormamaybe], AX  // This stores everything but its only left unchanged when a valid delimiter is present so it works but is a bit cheap
CMP AX, '+' 
JEQ return
CMP AX, '-' 
JEQ return
CMP AX, '*' 
JEQ return
CMP AX, '/' 
JEQ return
CMP AX, '=' 
JEQ return

SUB AX, '0'
MOV BX, [takenumericalinputvalue]
MUL BX, 0xA
ADD BX, AX
MOV [takenumericalinputvalue], BX
JMP takenumericalinputloop
// END OF takenumericalinput



// Taken from console test
readnext:
readnextloop:
MOV AX, [0x00F5]
CMP AX, 0x0
JEQ readnextloop
MOV AX, [0x00F3]
MOV BX, 0x00F5
MOV [BX], 0x0
RET
// END OF readnext



// Jump to this to use as: if () {return}.
return:
RET
// END OF return



printchar:
MOV [0x00F0], AX
MOV AX, 0x0001
MOV [0xF2], AX
printcharloop:
MOV AX, [0x00F2]
CMP AX, 0x1
JEQ printcharloop
RET
// Prints char in AX



// Do not use this inside a function already using this at some preceeding function call
// Global pointer functions


globalPointerInitialise:
MOV AX, GlobalPointerStart
MOV AX, [AX]
MOV [GlobalPointer], AX
RET

globalGetDataAtPointerIntoAX:
MOV BX, [GlobalPointer]
MOV AX, [BX]
RET

globalPointerSetDirectionIncrement:
MOV BX, 0x0
MOV [GlobalPointerDirection], BX
RET

globalPointerSetDirectionDecrement:
MOV BX, 0x1
MOV [GlobalPointerDirection], BX
RET

globalAXIntoPointer:
MOV BX, [GlobalPointer]
MOV [BX], AX
RET


globalPointerUpdate:

// Check flag decrementing
MOV BX, [GlobalPointerDirection]
CMP BX, 0x0
JEQ GlobalPointerIncrement

MOV AX, [GlobalPointer]
DEC AX
MOV [GlobalPointer], AX

RET

GlobalPointerIncrement:

MOV AX, [GlobalPointer]
INC AX
MOV [GlobalPointer], AX

RET

// Runs function in BX
MaintainAXRegisterFunctionWrapper:
MOV [AXCopyForWrapper], AX
CALL AX
MOV AX, [AXCopyForWrapper]
RET





NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP


// FUNCTION START
splitvalue:

MOV BX, AX

//BX
MOV [AXCOPY], AX
MOV AX, 0x00FF
AND BX, AX
MOV AX, [AXCOPY]

//AX
SUB AX, BX
QSR AX
QSR AX

// WASP SHR BUG FIX START
MOV [BXCOPY], BX
MOV BX, 0x00FF
AND AX, BX
MOV BX, [BXCOPY]
// WASP SHR BUG FIX END

RET
// Result, AX contains 0x**00 >> 8, BX contains 0x00** 
// splitvalue END


modulusbyten:
CALL splitvalue
MOD AX, 0d10
MOD BX, 0d10
QSL AX
QSL AX
ADD AX, BX
MOD AX, 0d10
RET

divisionbyten:
CALL splitvalue
MOV [divisionbytentemplow], BX
MOV BX, AX

DIV AX, 0d10
MOV [divisionbytentemphighfinal], AX

MOD BX, 0d10
QSL BX
QSL BX

MOV AX, [divisionbytentemplow]

ADD BX, AX
DIV BX, 0d10

MOV AX, [divisionbytentemphighfinal]
QSL AX
QSL AX

ADD AX, BX

RET



32bitdivisionbyten:

MOV [32divlow], BX

CALL 16bitdivisionbyten
MOV [32divhigh], AX

MOV AX, [32divlow]
QSL BX
QSL BX
MOV [32divrem], BX

CALL splitvalue
MOV [16divlow], BX

MOV BX, [32divrem]
ADD AX, BX

MOV BX, AX
DIV AX, 0d10
MOD BX, 0d10

MOV [TEMP2], AX

MOV AX, [16divlow]
QSL BX
QSL BX
ADD AX, BX

MOV BX, AX
DIV AX, 0d10
MOD BX, 0d10

MOV [32divrem], BX
MOV BX, [TEMP2]
QSL BX
QSL BX
ADD BX, AX

MOV AX, [32divhigh]
MOV [32divlow], BX

RET



16bitdivisionbyten:

CALL splitvalue
MOV [16divhigh], AX
MOV [16divlow], BX

MOV BX, AX
DIV AX, 0d10
MOD BX, 0d10
MOV [16divhigh], AX
// ResultHigh in AX Remainder in BX

MOV AX, [16divlow]
QSL BX
QSL BX
ADD AX, BX

MOV BX, AX
DIV AX, 0d10
MOD BX, 0d10

MOV [16divrem], BX

MOV BX, [16divhigh]
QSL BX
QSL BX
ADD AX, BX
MOV BX, [16divrem]
// Remainder in BX ResultLow in AX

RET



// Outputs AX contents in Decimal to console
outputBinToDec32:

MOV [nextNumberToConvertBinToDecHigh], AX
MOV [nextNumberToConvertBinToDecLow], BX

// Initialise pointer for array
CALL globalPointerInitialise
CALL globalPointerSetDirectionIncrement

// start of loop, this loop is to fill memory with the digits of the number starting from the last digit.
binToDecFillArrayLoop32: 

MOV AX, [nextNumberToConvertBinToDecHigh]
MOV BX, [nextNumberToConvertBinToDecLow]

CALL 32bitdivisionbyten
MOV [nextNumberToConvertBinToDecHigh], AX
MOV [nextNumberToConvertBinToDecLow], BX

MOV AX, [32divrem]
ADD AX, '0'
CALL globalAXIntoPointer

CALL globalPointerUpdate

MOV AX, [nextNumberToConvertBinToDecHigh]
CMP AX, 0x0
JNE notzero
MOV BX, [nextNumberToConvertBinToDecLow]
CMP BX, 0d9
JL exitLoop
notzero:
JMP binToDecFillArrayLoop32
exitLoop:

// end of loop
MOV BX, [nextNumberToConvertBinToDecLow]
MOD BX, 0d10
ADD BX, '0'
MOV AX, BX
CALL printchar
CALL globalPointerSetDirectionDecrement

// Updating pointer bc last loop increments 1 too many times..
CALL globalPointerUpdate

// start of loop, this loop prints the digits generated by the previous one but in reverse order
binToHexOutputLoop32:

CALL globalGetDataAtPointerIntoAX
CALL printchar

CALL globalPointerUpdate

// End condition, could be in function maybe
MOV AX, [GlobalPointer]
MOV BX, GlobalPointerStart
MOV BX, [BX]
CMP AX, BX

JL return

JMP binToHexOutputLoop32

// END OF outputBinToDec

// BX must contain pointer to start of text in memory
outputTextFromMemory:
MOV AX, [BX]
CMP AX, 0xFF
JEQ return
CALL printchar
ADD BX, 0x1
JMP outputTextFromMemory




takeInput:

CALL takenumericalinput
MOV AX, [takenumericalinputvalue]
MOV [operandA], AX

MOV AX, [operatormamaybe]
MOV [operator], AX

CALL takenumericalinput
MOV AX, [takenumericalinputvalue]
MOV [operandB], AX

RET



calculateResultant:
MOV AX, [operatormamaybe]
CMP AX, '*'
JNE notmultiply

MOV AX, [operandA]
MOV BX, [operandB]
CALL hexmulitply
notmultiply:

CALL outputBinToDec32
RET



hexmulitply:

CALL anbngenerator

MOV BX, [AN00]

MUL AX, BX
MOV [ARG3], AX

MOV AX, [AN01]
MOV BX, [BN00]
MUL AX, BX
MOV [TEMP2], AX
MOV AX, [AN00]
MOV BX, [BN01]
MUL BX, AX
MOV AX, [TEMP2]
ADD AX, BX
MOV [ARG4], AX

MOV AX, [AN01]
MOV BX, [BN01]
MUL AX, BX
MOV [ARG5], AX

CALL combinethree

// Print them all here with the hex to dec print function
MOV AX, [RETURN0]
MOV BX, [RETURN1]
QSL BX
QSL BX
ADD BX, AX
// BX contains the high component
MOV [RETURN0], BX
MOV AX, [RETURN2]
MOV BX, [RETURN3]
MUL AX, 0x10
MUL AX, 0x10
ADD AX, BX
MOV BX, [RETURN0]

RET
// hexmulitply END


anbngenerator:

MOV [TEMP1], BX

CALL splitvalue

MOV [AN00], AX
MOV [AN01], BX

MOV AX, [TEMP1]

CALL splitvalue

MOV [BN00], AX
MOV [BN01], BX

RET
// anbngenerator END


// VARIABLES

takenumericalinputvalue: DC.W 0x1FFF
nextNumberToConvertBinToDec: DC.W 0x1FFE

// Vars for 'array' or 'GlobalPointer'
GlobalPointerStart: DC.W 0x1000
GlobalPointer: DC.W 0x1FFC
GlobalPointerDirection: DC.W 0x1FFB
// 0 == increment, 1 == decrement

AXCopyForWrapper: DC.W 0x1FFA

AXCOPY: DC.W 0x1FF8
BXCOPY: DC.W 0x1FFD

divisionbytentemplow: DC.W 0x1FF7
divisionbytentemphighfinal: DC.W 0x1FF6

32divhigh: DC.W 0x1DFF
32divlow: DC.W 0x1DFE
32divrem: DC.W 0x1DF7
16divlow: DC.W 0x1DFB
16divhigh: DC.W 0x1DFA
16divrem: DC.W 0x1DF8
copy: DC.W 0x1DF9

TEMP2: DC.W 0x1DCA

operandA: DC.W 0x1DCE
operandB: DC.W 0x1DF6
operatormamaybe: DC.W 0x1DCF
operator: DC.W 0x1DC7
resultant: DC.W 0x1DF4

nextNumberToConvertBinToDecHigh: DC.W 0x1DE8
nextNumberToConvertBinToDecLow: DC.W 0x1DE7


TEMP1: DC.W 0x1DF5
TEMP3: DC.W 0x1DF3

AN00: DC.W 0x1DF2
AN01: DC.W 0x1DF1
BN00: DC.W 0x1DF0
BN01: DC.W 0x1DCB

ARG3: DC.W 0x1DEF
ARG4: DC.W 0x1DEE
ARG5: DC.W 0x1DED


RETURN0: DC.W 0x1DEC
RETURN1: DC.W 0x1DEB
RETURN2: DC.W 0x1DEA
RETURN3: DC.W 0x1DE9

// Output text begin here
text0: DC.W 'P'
text1: DC.W 'l'
text2: DC.W 'e'
text3: DC.W 'a'
text4: DC.W 's'
text5: DC.W 'e'
text6: DC.W ' '
text7: DC.W 'e'
text8: DC.W 'n'
text9: DC.W 't'
text10: DC.W 'e'
text11: DC.W 'r'
text12: DC.W ' '
text13: DC.W 'y'
text14: DC.W 'o'
text15: DC.W 'u'
text16: DC.W 'r'
text17: DC.W ' '
text18: DC.W 'e'
text19: DC.W 'x'
text20: DC.W 'p'
text21: DC.W 'r'
text22: DC.W 'e'
text23: DC.W 's'
text24: DC.W 's'
text25: DC.W 'i'
text26: DC.W 'o'
text27: DC.W 'n'
text28: DC.W ' '
text29: DC.W 'i'
text30: DC.W 'n'
text31: DC.W ' '
text32: DC.W 't'
text33: DC.W 'h'
text34: DC.W 'e'
text35: DC.W ' '
text36: DC.W 'f'
text37: DC.W 'o'
text38: DC.W 'r'
text39: DC.W 'm'
text40: DC.W 'a'
text41: DC.W 't'
text42: DC.W ' '
text43: DC.W '"'
text44: DC.W 'a'
text45: DC.W '+'
text46: DC.W 'b'
text47: DC.W '='
text48: DC.W '"'
text49: DC.W ' '
text50: DC.W 'm'
text51: DC.W 'a'
text52: DC.W 'x'
text53: DC.W ' '
text54: DC.W 'i'
text55: DC.W 'n'
text56: DC.W 'p'
text57: DC.W 'u'
text58: DC.W 't'
text59: DC.W ' '
text60: DC.W 'n'
text61: DC.W 'u'
text62: DC.W 'm'
text63: DC.W 'b'
text64: DC.W 'e'
text65: DC.W 'r'
text66: DC.W ' '
text67: DC.W 'i'
text68: DC.W 's'
text69: DC.W ' '
text70: DC.W '6'
text71: DC.W '5'
text72: DC.W '5'
text73: DC.W '3'
text74: DC.W '5'
text75: DC.W ':'
text76: DC.W 0xA
textendmarker: DC.W 0xFF

youentered0: DC.W 'Y'
youentered1: DC.W 'o'
youentered2: DC.W 'u'
youentered3: DC.W ' '
youentered4: DC.W 'e'
youentered5: DC.W 'n'
youentered6: DC.W 't'
youentered7: DC.W 'e'
youentered8: DC.W 'r'
youentered9: DC.W 'e'
youentered10: DC.W 'd'
youentered11: DC.W ':'
youentered12: DC.W 0xA
youenteredend: DC.W 0xFF